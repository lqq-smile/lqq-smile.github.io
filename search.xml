<?xml version="1.0" encoding="utf-8"?>
<search> 
  
    
    <entry>
      <title>为何你当不了徐庶</title>
      <link href="/2018/06/23/%E4%B8%BA%E4%BD%95%E4%BD%A0%E5%BD%93%E4%B8%8D%E4%BA%86%E5%BE%90%E5%BA%B6/"/>
      <url>/2018/06/23/%E4%B8%BA%E4%BD%95%E4%BD%A0%E5%BD%93%E4%B8%8D%E4%BA%86%E5%BE%90%E5%BA%B6/</url>
      <content type="html"><![CDATA[<h4 id="徐庶面对着哪些难题？"><a href="#徐庶面对着哪些难题？" class="headerlink" title="徐庶面对着哪些难题？"></a>徐庶面对着哪些难题？</h4><blockquote><p>《新三国》比旧三国在感情上面更加细致。</p></blockquote><ol><li>关、张、赵等不服。</li><li>你真的确定你的计谋是对的？万一打了败仗，你知道后果吗？</li><li>你确定你的能力足够？会不会想不出点子？</li><li>为人处世的能力足够吗？平时说话各方面合理吗？人际关系处理得好吗？情商够吗？</li><li>自己的计划能力足够吗？执行力足够吗？</li></ol><p>所以，你以为军师好做？刘备请徐庶做军师，徐庶不敢答应，绝对不是故意谦虚，而是真的怕做不好丢面子打败仗。首先心理这关就不好过。</p><h4 id="如果是自己呢？"><a href="#如果是自己呢？" class="headerlink" title="如果是自己呢？"></a>如果是自己呢？</h4><p>如果自己就是徐庶，并且真的有这样的才能，同样的问题是不是一样会出现。</p><p> 这跟跳槽找更高职位是不是同样的道理？如何评估自己真的具备了跳槽的实力？</p><h4 id="得到什么启示"><a href="#得到什么启示" class="headerlink" title="得到什么启示"></a>得到什么启示</h4><ol><li>做事前多考虑考虑，别冲动。</li><li>不要用“感觉”来做决定。我感觉我可以，这话听起来多不靠谱。</li><li>详细的计划和客观的分析使成功率大许多。</li><li>冷静处事。</li><li>提升责任心。清楚答应意味着什么，不答应意味着什么。</li></ol>]]></content>
      
      <categories>
          
          <category> 为人处世 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 情商 </tag>
            
            <tag> 做事 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>论做事靠谱性</title>
      <link href="/2018/06/23/%E8%AE%BA%E5%81%9A%E4%BA%8B%E9%9D%A0%E8%B0%B1%E6%80%A7/"/>
      <url>/2018/06/23/%E8%AE%BA%E5%81%9A%E4%BA%8B%E9%9D%A0%E8%B0%B1%E6%80%A7/</url>
      <content type="html"><![CDATA[<h4 id="何为靠谱"><a href="#何为靠谱" class="headerlink" title="何为靠谱"></a>何为靠谱</h4><blockquote><p>与高情商者聊天，与靠谱的人做事</p></blockquote><p>高情商者未必靠谱。</p><p>有些人很会说话，句句让你乐开了花。可是他做事丢三落四，没头没尾。</p><p>有些人很不讨喜，说话像僵尸一般，但做事很得力，往往拿得出成果，出得了有成绩。</p><p>第2种人就是靠谱的人。</p><h4 id="为何不靠谱"><a href="#为何不靠谱" class="headerlink" title="为何不靠谱"></a>为何不靠谱</h4><ol><li>关注点只在讨人喜欢上，对做事效果毫无兴趣。</li><li>缺少责任心。</li><li>没有经历过大的挫折，对失败的可怕没有亲身体会过。</li></ol><h4 id="如何提升靠谱性"><a href="#如何提升靠谱性" class="headerlink" title="如何提升靠谱性"></a>如何提升靠谱性</h4><ol><li>反思自己的失败事迹。感受失败带来的挫折感。</li><li>好好体会失败给自己带来的职业生涯上的坏处。</li><li>天天问自己：如果我今天不做好，明天公司就会炒我鱿鱼，我会有多惨。</li><li>反问自己：你还有多少次失败的机会呢？</li><li>你只顾着做事，忘记了为人处世的重要性了吗？</li></ol>]]></content>
      
      <categories>
          
          <category> 为人处世 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 情商 </tag>
            
            <tag> 做事 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>好马出在腿上，能人出在嘴上</title>
      <link href="/2018/06/22/%E5%A5%BD%E9%A9%AC%E5%87%BA%E5%9C%A8%E8%85%BF%E4%B8%8A%EF%BC%8C%E8%83%BD%E4%BA%BA%E5%87%BA%E5%9C%A8%E5%98%B4%E4%B8%8A/"/>
      <url>/2018/06/22/%E5%A5%BD%E9%A9%AC%E5%87%BA%E5%9C%A8%E8%85%BF%E4%B8%8A%EF%BC%8C%E8%83%BD%E4%BA%BA%E5%87%BA%E5%9C%A8%E5%98%B4%E4%B8%8A/</url>
      <content type="html"><![CDATA[<h5 id="吃低情商的亏，太痛了"><a href="#吃低情商的亏，太痛了" class="headerlink" title="吃低情商的亏，太痛了"></a>吃低情商的亏，太痛了</h5><p>低情商，就是平时脑袋的关注点永远不在为人处世上，而是别的事情。一个人如果对为人处世之道从来不思考，不改正错误，当然在这上面一再吃亏。</p><h5 id="好马出在腿上，能人出在嘴上"><a href="#好马出在腿上，能人出在嘴上" class="headerlink" title="好马出在腿上，能人出在嘴上"></a>好马出在腿上，能人出在嘴上</h5><p>一匹好马，跑得飞快，但由于不会说话，它只是供人驱策的畜生。</p><p>能人从来不需要在专业技术上有过份突出的能力，但他的嘴巴可厉害了。他知道什么时候说什么话，他洞察人心，深知人情世故。</p><p>你愿意做畜生还是做能人？</p><h5 id="专业技术能力与说话能力"><a href="#专业技术能力与说话能力" class="headerlink" title="专业技术能力与说话能力"></a>专业技术能力与说话能力</h5><p>这两种很多情况下是矛盾的。你很多时候都不可能同时在这两方面都很精通，最多只能在一方面做好。</p><p>但做到两方面都不太差，是可能的。</p><p>为人处世非常强的人，可以不会任何专业技术，单靠一把嘴活着。但这样的人能有几个？</p><p>所以，最好是有过强的专业技术，同时在为人处世上不太差。</p><ol><li>知道哪些话是明显得罪人的。</li><li>改正以自我为中心的思维习惯。说话不要只图自己爽。</li><li>平时要有警惕之心。多反思自己的行为对自己有好处。</li><li>学会讨好别人。只有跟别人好好相处才可以将事办成。</li><li>再强的人，如果不能融入团队，死都不知道怎么死的。</li><li>绝对不能得罪领导！</li><li>学会圆滑，学会委婉，改正直肠直肚的坏习惯。</li></ol>]]></content>
      
      <categories>
          
          <category> 为人处世 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 情商 </tag>
            
            <tag> 说话 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>逻辑回归数学原理</title>
      <link href="/2018/06/22/%E9%80%BB%E8%BE%91%E5%9B%9E%E5%BD%92%E6%95%B0%E5%AD%A6%E5%8E%9F%E7%90%86/"/>
      <url>/2018/06/22/%E9%80%BB%E8%BE%91%E5%9B%9E%E5%BD%92%E6%95%B0%E5%AD%A6%E5%8E%9F%E7%90%86/</url>
      <content type="html"><![CDATA[<h3 id="求解原理"><a href="#求解原理" class="headerlink" title="求解原理"></a>求解原理</h3><h4 id="Sigmoid-函数"><a href="#Sigmoid-函数" class="headerlink" title="Sigmoid 函数"></a>Sigmoid 函数</h4><script type="math/tex; mode=display">y={1\over {1+e^{-z}}}</script><p>先看看这个函数样子：</p><p><img src="https://gss3.bdstatic.com/-Po3dSag_xI4khGkpoWK1HF6hhy/baike/c0%3Dbaike80%2C5%2C5%2C80%2C26/sign=33afcd8303f79052fb124f6c6d9abcaf/d009b3de9c82d158dfb4e7218a0a19d8bc3e426f.jpg" alt=""></p><p>可以看到，无论z取值如何，这个函数的结果总是在0到1之间。且以原点对称。</p><p>0和1，我们是不是联想到概率呢？概率总是在0与1之间取值。</p><h4 id="联想"><a href="#联想" class="headerlink" title="联想"></a>联想</h4><p>假设有一堆数据。这些数据有一些特征值，还有一个分类结果。那么我们可不可以像线性回归那样通过特征值求出一个参数向量$\theta$,使模拟出来的分类的概率跟真实分类最接近呢？如下表达：</p><script type="math/tex; mode=display">h_\theta(x)={1\over {1+{e^{-\theta^TX}}}}</script><p>其中，$h_\theta(x)$为每个样式计算出来的概率值，比如为80%（0.8），即为分类1的概率为80%。比如，已知某样式分类为1，$h_\theta(x)$就是出现该样本数据分类为1的概率。我们当然是希望概率越符合越好。即如果真实分类为分类1，我们希望概率值越大越好，反之，我们希望概率越小越好。如果有N个样本，那么符合每一个分类的概率为他们的联合概率。即计算累乘。</p><h4 id="公式推导"><a href="#公式推导" class="headerlink" title="公式推导"></a>公式推导</h4><p>设分类为1时，概率为$h_\theta(x)$，那么分类为0时就是$1-h_\theta(x)$。那么：</p><script type="math/tex; mode=display">\begin{cases}P(y_i=1|x_i;\theta)=h_\theta(x_i) ={1\over {1+{e^{-\theta^Tx_i}}}} \\P(y_i=0|x_i;\theta)=1-h_\theta(x_i)=1-{1\over {1+{e^{-\theta^Tx_i}}}} \\\end{cases}</script><p>整合上面两个式子，可以设样本如此分类出现的概率为：</p><script type="math/tex; mode=display">P(y_i|x_i;\theta)=h_\theta(x_i)^{y_i}(1-h_\theta(x_i))^{1-y_i}</script><p>上面那个式子是要解释一下的，因为一开始我也看不懂。</p><p>因为y只能取1和0，那么试一下将1和0代入上面那个式子看看？上面那个式子并不是推导出来的，而是设出来的。我们为了可以计算y=0或者1的概率，即随意计算这两个结果的概率，而不是只能计算其中一个值，于是设出上面那个式子。显然，无论y取值是1还是0，结果都是对的。</p><p>有了上面那个式子，那么，根据联合概率公式（这个公式是机器学习中非常常见），所有样本这样出现的总概率为：</p><script type="math/tex; mode=display">P(y|x;\theta)= \prod_{i=1}^m P(y_i|x_i;\theta)=\prod_{i=1}^m h_\theta(x_i)^{y_i}(1-h_\theta(x_i))^{1-y_i}</script><p>取对数，得：</p><script type="math/tex; mode=display">ln(P(y|x;\theta))=ln( \prod_{i=1}^m P(y_i|x_i;\theta))=ln(\prod_{i=1}^m h_\theta(x_i)^{y_i}(1-h_\theta(x_i))^{1-y_i})</script><p>于是，我们可以这样求偏导：</p><script type="math/tex; mode=display">(ln(P(y|x;\theta)))'=(ln(\prod_{i=1}^m h_\theta(x_i)^{y_i}(1-h_\theta(x_i))^{1-y_i}))' \\=(\sum_{i=1}^m(y_ilnh_\theta(x_i)+(1-y_i)ln(1-h_\theta(x_i))))' \\=\sum_{i=1}^m(y_i {1\over {h_\theta(x_i)}}-(1-y_i){1\over{1-h_\theta(x_i)}})(h_\theta(x_i))'</script><p>问题来了，</p><script type="math/tex; mode=display">(h_\theta(x))'</script><p>是什么？上面已知：</p><script type="math/tex; mode=display">h_\theta(x)={1\over {1+{e^{-\theta^TX}}}}</script><p>所以，关键是对Sigmoid 函数求导。</p><h4 id="sigmoid函数求导"><a href="#sigmoid函数求导" class="headerlink" title="sigmoid函数求导"></a>sigmoid函数求导</h4><script type="math/tex; mode=display">(h_\theta(x_i))'=({1\over {1+{e^{-\theta^Tx_i}}}})' \\</script><p>设$z=\theta^Tx_i$,$y={1\over{1+e^{-z}}}$我们有：</p><script type="math/tex; mode=display">(h_\theta(x_i))' \\=({1\over {1+{e^{-\theta^Tx_i}}}})' \\=({1\over {1+{e^{-z}}}})'  \\=-{1\over({1+e^{-z}})^2}(1+e^{-z})' \\=-{1\over({1+e^{-z}})^2}(-e^{-z}) \\={1\over{1+e^{-z}}}-{1\over({1+e^{-z}})^2} \\=y(1-y)</script><p>使用上面的变量是为了简化表达。</p><h4 id="继续推导"><a href="#继续推导" class="headerlink" title="继续推导"></a>继续推导</h4><p>所以，我们继续上面的偏导推导,设$h_\theta(x_i)=g(\theta^Tx_i)$：</p><script type="math/tex; mode=display">(ln(P(y|x;\theta)))'=(ln(\prod_{i=1}^m h_\theta(x_i)^{y_i}(1-h_\theta(x_i))^{1-y_i}))' \\=(\sum_{i=1}^m(y_ilnh_\theta(x_i)+(1-y_i)ln(1-h_\theta(x_i))))' \\=\sum_{i=1}^m(y_i {1\over {h_\theta(x_i)}}-(1-y_i){1\over{1-h_\theta(x_i)}})(h_\theta(x_i))' \\=\sum_{i=1}^m(y_i {1\over {g(\theta^Tx_i)}}-(1-y_i){1\over{1-g(\theta^Tx_i)}})g(\theta^Tx_i)(1-g(\theta^Tx_i))(\theta^Tx_i)' \\=\sum_{i=1}^m(y_i {1\over {g(\theta^Tx_i)}}-(1-y_i){1\over{1-g(\theta^Tx_i)}})g(\theta^Tx_i)(1-g(\theta^Tx_i))x_i^j \\=\sum_{i=1}^m (y_i-g(\theta^Tx_i))x_i^j</script><p>其中，$x_i^j$表示第i行，第j个特征值样本。</p><h4 id="梯度下降"><a href="#梯度下降" class="headerlink" title="梯度下降"></a>梯度下降</h4><p>通过上面的推导，我们已经求得了在逻辑回归中，任意一个参数$\theta_j$的迭代方式。设$\alpha$为导数迭代的步长。为了求出$\theta$向量，我们可以使用梯度下降算法。首先，我们随意初始化一个$\theta$向量，然后不断向着梯度下降的方向进行迭代，直到每一个向量值不再下降为止。所以迭代方式：</p><script type="math/tex; mode=display">\theta_j := \theta_j-\alpha{1\over m}\sum_{i=1}^m (y_i-g(\theta^Tx_i))x_i^j</script><p>只要迭代的方向总是与导数正负相反，就会向下降的方向。${1\over m}$是为了消除累加影响。$\alpha$一般取值很小，以减少步长。</p><p>通过上面的方式，我们就巧妙地算出了最佳参数向量。</p>]]></content>
      
      <categories>
          
          <category> 人工智能 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 逻辑回归 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>性能改进方案</title>
      <link href="/2018/06/21/%E6%9F%A5%E7%9C%8B%E6%80%A7%E8%83%BD%E6%94%B9%E8%BF%9B%E6%96%B9%E6%A1%88/"/>
      <url>/2018/06/21/%E6%9F%A5%E7%9C%8B%E6%80%A7%E8%83%BD%E6%94%B9%E8%BF%9B%E6%96%B9%E6%A1%88/</url>
      <content type="html"><![CDATA[<h1 id="文档目的"><a href="#文档目的" class="headerlink" title="文档目的"></a>文档目的</h1><h2 id="目前查重功能的主要问题"><a href="#目前查重功能的主要问题" class="headerlink" title="目前查重功能的主要问题"></a>目前查重功能的主要问题</h2><p>目前系统的查重功能只用在立项表单的提交功能上。当立项功能提交时触发查重检查。由于查重算法本身性能不是很快，在文档有1000多个时耗时大概5秒多；如果文档数量增加，耗时只会更多。</p><h2 id="文档的要点"><a href="#文档的要点" class="headerlink" title="文档的要点"></a>文档的要点</h2><p>本文档主要讨论双创查重模块性能改进的方式方法。核心目标是改善用户体验。我们也许最终没有加快查重算法的性能，但是，我们的目标是改善用户的体验。使用户在使用过程中不会有不舒服的情绪。</p><h1 id="文档目录"><a href="#文档目录" class="headerlink" title="文档目录"></a>文档目录</h1><p>本文档讨论话题如下：</p><blockquote><ul><li>预先触发</li><li>支持增量数据</li><li>保存运行结果</li><li>改进运行节点</li><li>多节点运行</li></ul></blockquote><h1 id="支持增量数据"><a href="#支持增量数据" class="headerlink" title="支持增量数据"></a>支持增量数据</h1><p>目前的程序不支持增量查重数据，这意味着新通过的成果推广或者立项无法作为参考依据。可改进程序，支持增量数据写入缓存。</p><h2 id="改进点"><a href="#改进点" class="headerlink" title="改进点"></a>改进点</h2><h3 id="立项"><a href="#立项" class="headerlink" title="立项"></a>立项</h3><blockquote><p><strong>1、立项通过后，添加到文档查重缓存中</strong><br><strong>2、立项删除后，从文档查重缓存中删除（如果有）</strong><br><strong>3、通过状态的立项修改后，重新加载到缓存（如果有）</strong></p></blockquote><h3 id="成果推广"><a href="#成果推广" class="headerlink" title="成果推广"></a>成果推广</h3><blockquote><p><strong>1、成果推广通过后，添加到文档查重缓存中</strong><br><strong>2、成果推广删除后，从文档查重缓存中删除（如果有）</strong><br><strong>3、通过状态的成果推广修改后，重新加载到缓存（如果有）</strong></p></blockquote><h1 id="性能改进点"><a href="#性能改进点" class="headerlink" title="性能改进点"></a>性能改进点</h1><p>为了提升用户的体验，加快文档查重对比结果的输出可以在如下几点入手：</p><h2 id="预先触发"><a href="#预先触发" class="headerlink" title="预先触发"></a>预先触发</h2><p> 目前触发检查的点是立项提交时同时运行查重的程序。一般用户需要等待4-5秒的时间。那么，在提交之前预先触发检查可以减少用户等待或者免于用户等待。</p><h3 id="预先触发的方案"><a href="#预先触发的方案" class="headerlink" title="预先触发的方案"></a>预先触发的方案</h3><h4 id="方案一-在立项的表单页面添加“对比”按钮。"><a href="#方案一-在立项的表单页面添加“对比”按钮。" class="headerlink" title="方案一 在立项的表单页面添加“对比”按钮。"></a>方案一 在立项的表单页面添加“对比”按钮。</h4><h5 id="添加方式说明"><a href="#添加方式说明" class="headerlink" title="添加方式说明"></a>添加方式说明</h5><blockquote><p>在立项表单页添加对比按钮。当用户填写完项目论证信息后，可以点击对比按钮。那么系统将在后台触发查重检查操作。</p></blockquote><h5 id="解决用户点击“对比”后再修改数据的问题"><a href="#解决用户点击“对比”后再修改数据的问题" class="headerlink" title="解决用户点击“对比”后再修改数据的问题"></a>解决用户点击“对比”后再修改数据的问题</h5><blockquote><p>如果用户在点击完“对比”后发现先前填写的数据需要修改呢？</p></blockquote><p>用户返回修改数据是无法避免的问题。<br>如果用户修改了项目论证中的数据，只能再次触发查重。这里涉及到两个问题：</p><blockquote><ol><li>如果之前的查重任务还没有完成，我们应该采取什么样的操作？</li><li>如果多次触发查重，是否会带来系统多重任务造成性能问题？</li></ol></blockquote><h6 id="解决方法"><a href="#解决方法" class="headerlink" title="解决方法"></a><strong>解决方法</strong></h6><p>由于页面提供了预先触发的功能，那么重复提交查重功能是无法避免的。但是，重复提交查重请求不代表我们一定会执行。由于我们后台的查重任务是分页抽取文档数据执行算法的，我们可以对同一个立项设置一个任务id,后面的提交请求执行前可以先检查是否正在对同一个立项执行查重任务。如果有，我们可以设置下一个分页任务不再执行，而重新开始新的查重任务。</p><h4 id="方案二-不添加“对比按钮”-自动执行查重任务"><a href="#方案二-不添加“对比按钮”-自动执行查重任务" class="headerlink" title="方案二 不添加“对比按钮”,自动执行查重任务"></a>方案二 不添加“对比按钮”,自动执行查重任务</h4><blockquote><p>当用户填写完一个项目论证项后，自动对该填写触发检查<br><strong>说明：</strong><br>1、用户在填写项目论证时，每一个框填写的文字都是比较多的，这意味着每一项的填写都是需要花费至少一分钟的时间；<br>2、基于上一点，如果用户填写第一项时，再填写第二项时，自动触发对第一项的查重检查，并不会影响用户，因为用户通常在第二项没有填写完成时第一项的查重结果就返回来了；<br>3、由于项目论证下面还有需要用户填写的内容，所以当用户填写完项目论证以后，通常可以继续正常填写下面的内容。所有查重结果返回后，用户并不会感觉系统已经提前完成了查重的任务；<br>4、用户在提交时，系统已经完成了所有项目论证的查重工作，所以用户不会等待查重结果返回。</p></blockquote><h5 id="用户返回修改项目论证的数据"><a href="#用户返回修改项目论证的数据" class="headerlink" title="用户返回修改项目论证的数据"></a>用户返回修改项目论证的数据</h5><p>与方案一一样，用户同样有可能返回修改先前填写的数据。这时解决思路是一样的。我们可以设置一个查重任务id，当同一个查重数据到来时，先前的任务如果还没有结束，可以提前让它结束；从而开始执行当前查重任务。</p><h2 id="保存对比结果"><a href="#保存对比结果" class="headerlink" title="保存对比结果"></a>保存对比结果</h2><p>由于目前的设计不保存检查的结果，那么当工单进入专家审核环节时，必须再次触发检查，这样的检查没有意义。保存检查的结果可以减少查重的次数。</p><h3 id="保存方案的设计原则"><a href="#保存方案的设计原则" class="headerlink" title="保存方案的设计原则"></a>保存方案的设计原则</h3><blockquote><p>查重的数据应该独立于业务模块<br>查重应该是一个独立的公用模块<br>查重模块的代码和数据表应独立于业务模块（代码目前是独立的模块）<br>查重模块的代码应该可以方便抽取成为微服务<br>数据表设计尽量简单，避免复杂</p></blockquote><h3 id="数据表设计"><a href="#数据表设计" class="headerlink" title="数据表设计"></a>数据表设计</h3><p>查重的表是独立的模块，但是，它还是要保存少量的业务数据。比如业务id和业务类型（随意自定义）。</p><div class="table-container"><table><thead><tr><th style="text-align:center">字段名</th><th style="text-align:center">中文名字</th><th style="text-align:center">类型</th><th style="text-align:left">备注</th></tr></thead><tbody><tr><td style="text-align:center">id</td><td style="text-align:center">id的值</td><td style="text-align:center">varchar2</td><td style="text-align:left"></td></tr><tr><td style="text-align:center">business_id</td><td style="text-align:center">业务id</td><td style="text-align:center">varchar2</td><td style="text-align:left">32位，与业务类型组成复合主键</td></tr><tr><td style="text-align:center">business_type</td><td style="text-align:center">业务类型</td><td style="text-align:center">varchar2</td><td style="text-align:left">自定义相应的类型</td></tr><tr><td style="text-align:center">hash</td><td style="text-align:center">哈希值</td><td style="text-align:center">varchar2</td><td style="text-align:left">对应内容的哈希值，不需要直接保存原始内容值，只需要保存哈希，以此检测内容是否改变过</td></tr><tr><td style="text-align:center">create_time</td><td style="text-align:center">保存时间</td><td style="text-align:center">date</td><td style="text-align:left"></td></tr><tr><td style="text-align:center">state</td><td style="text-align:center">状态</td><td style="text-align:center">varchar2</td><td style="text-align:left">1运行查重中 2 查重结束</td></tr><tr><td style="text-align:center">result_state</td><td style="text-align:center">是否存在可能重复的文档</td><td style="text-align:center">varchar2</td><td style="text-align:left">1存在 2 不存在</td></tr><tr><td style="text-align:center">result</td><td style="text-align:center">查重结果</td><td style="text-align:center">clob</td><td style="text-align:left">如果触发前检查发现hash值没有发生变化，直接返回该字段结果</td></tr></tbody></table></div><h3 id="逻辑说明"><a href="#逻辑说明" class="headerlink" title="逻辑说明"></a>逻辑说明</h3><blockquote><p>1、业务模块创建一个查重任务。</p><blockquote><p> 参数：<br> 业务id 业务类型 查重内容</p></blockquote><p>2、检查该业务查重任务是否正在运行</p><blockquote><p>如果正在运行，则提前结束该任务（禁止下一个分页的查重，标志必须结束任务）<br>执行该查重任务</p></blockquote><p>3、返回查重结果。查重结果可以立即显示也可以先缓存，在需要的时候再显示。<br>4、一个业务类型可能查重的触发次数不止一次。当下一次触发时，如果检查hash的结果与先前一致，不必触发查重任务，只需要返回先前查重的结果。<br>5、修改查重状态。</p></blockquote><h2 id="改进运行节点"><a href="#改进运行节点" class="headerlink" title="改进运行节点"></a>改进运行节点</h2><p>由于查重算法比较耗系统的资源，可以将查重任务转移到其他模块独立运行：</p><blockquote><p>转换到BPP模块。<br>设置独立的微服务模块。并多节点运行。这个方案受限于系统的硬件资源情况。</p></blockquote><h2 id="多节点运行"><a href="#多节点运行" class="headerlink" title="多节点运行"></a>多节点运行</h2><p>多节点可以将查重的数据量N倍减少。可以大大提升效率，但对资源比较敏感。由于正式环境节点数量和开发难度的问题，目前这个方案可以作为备选方案。</p><h3 id="多节点运行方案（草稿）"><a href="#多节点运行方案（草稿）" class="headerlink" title="多节点运行方案（草稿）"></a>多节点运行方案（草稿）</h3><blockquote><p>1、接到任务的节点成为查重任务的管理者和协调者（NameNode）<br>2、管理者根据文档总数量确定各节点任务，向各节点（taskNode,也可以是它自身）发送任务<br>3、任务的参数为查重的内容和分页的游标，文档数量<br>4、NameNode等待各节点返回各自的查重结果<br>5、所有taskNode返回查重结果后，NameNode合并结果，排序，生成最后结果<br>6、任何一个节点运行出错或者没有返回，该查重任务失败。（没有必要设计复杂的容错能力）</p></blockquote><h2 id="延时处理"><a href="#延时处理" class="headerlink" title="延时处理"></a>延时处理</h2><p>性能改进的另一种思路是使用消息队列延时处理查重任务。但目前系统要求查重不能延时处理，因此这个方案可以作为备选。</p><h3 id="延时处理概念方案"><a href="#延时处理概念方案" class="headerlink" title="延时处理概念方案"></a>延时处理概念方案</h3><blockquote><p>1、确定延时通知方案（短信、站内信、其他通知手段）<br>2、设计延时提交方案。（可以设置工单必须等待查重任务结束后才可以实质提交（系统自动提交），如果有重复内容，需要用户手动确认）</p></blockquote>]]></content>
      
      <categories>
          
          <category> 架构方案 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 性能 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>为什么道理都懂，可就是做不到</title>
      <link href="/2018/06/21/%E4%B8%BA%E4%BB%80%E4%B9%88%E9%81%93%E7%90%86%E4%BD%A0%E9%83%BD%E6%87%82%EF%BC%8C%E4%BD%86%E5%B0%B1%E6%98%AF%E5%81%9A%E4%B8%8D%E5%88%B0/"/>
      <url>/2018/06/21/%E4%B8%BA%E4%BB%80%E4%B9%88%E9%81%93%E7%90%86%E4%BD%A0%E9%83%BD%E6%87%82%EF%BC%8C%E4%BD%86%E5%B0%B1%E6%98%AF%E5%81%9A%E4%B8%8D%E5%88%B0/</url>
      <content type="html"><![CDATA[<blockquote><p> 知易行难释义：</p><p> “知道应该做什么”很容易，但“实际上怎么做”却不一定是对的。因为行，并不是由知驱动的。“知道应该做什么”和“想做什么”是两码事，而后者才是起决定性作用。</p></blockquote><p>经常有人说：“道理我都懂，就是做不到”，或者说“道理说说容易，做起来难。”。说这句话的人的潜台词是什么呢？</p><h4 id="我的理解"><a href="#我的理解" class="headerlink" title="我的理解"></a>我的理解</h4><ol><li>道理并没有真正懂：好多只是骗自己。</li><li>道理我都懂。我虽然知道这样做，是对我有好处的，我完全理解你所说的“做这件事的好处，或者不做的坏处”。可我就是做不到。潜台词是“因为我懒惰，因为我不想离开舒适圈”！但是即使这件事的利弊真如你所说，这也不足以推动我，让我放弃原有的状态而照你说的去做。因为我根本不想改变。</li><li>本质上说，不是“做不到”，而是当下，做出了选择，选择“不去做”！为什么不去做，是因为后果和结局可逆，有婉转的余地，如果产生一定的后果或者结果不可逆，肯定会产生去做的动力！</li></ol><h4 id="道理你真的懂吗？"><a href="#道理你真的懂吗？" class="headerlink" title="道理你真的懂吗？"></a>道理你真的懂吗？</h4><ol><li>世上，未有知而不行者，只因不知。——王阳明</li><li>懂而不做，只因不懂。所以别说懂，你只是听过这种道理。</li><li>你听的道理都是别人的道理，你还没有经历，还没有把它变成自己 的道理。所以你做不到。</li><li>道理只有你真正懂了，应用了，它才是有意义的。你看过那么多心灵鸡汤成功学，却每天都在无所事事，有什么用呢？安慰自己吗？道理是人家的，行动才是自己的。那些说“道理我都懂，就是做不到”的人，不是他们做不到，是他们还没懂。</li><li>所谓的“懂”，可以有很多层次。一个道理，100个人都说懂，但懂1分的，执行力绝对比不上懂100分的。</li><li>大部分人的问题都在于“不知道自己不知道”。于是，纠结于为什么“知道”却“做不到”。因此，区分开“知道”和“懂得”是非常有意义的，这样可以帮助我们做到诚实与谦卑，如果“不能行”，就是说明我们没有真正“知道”。</li></ol><h4 id="知道，为什么做不到"><a href="#知道，为什么做不到" class="headerlink" title="知道，为什么做不到"></a>知道，为什么做不到</h4><h5 id="利害体验不足"><a href="#利害体验不足" class="headerlink" title="利害体验不足"></a>利害体验不足</h5><p>趋利避害是人的本性。<strong>当趋利避害的行为确实获得一些利益，则会指导这次行为的价值判断。利害认知也会得到强化，并逐步融入价值观念中，成为其价值观的一部分，并做为以后的行为依据。</strong></p><p>所谓利益，就是当事人切实的感觉到自己这么做的好处。</p><p>人之所以知易行难，原因之一就是：利害体验不足。</p><p>一个人之所以对某一件事情，一直秉持“道理我都懂，但就是做不到”，恰恰是这件事对于他而言，还没有让他感受到“做到之后的好处”以及“做不到的坏处”。当然，不是说一点感受都没有，而是感受并不深刻，他没有真正从践行中获益。</p><p>也就是说，这两种情形会导致人们“知易行难”：</p><blockquote><ol><li>对努力后的利益，感觉不足；</li><li>对不努力的害处感受不深</li></ol></blockquote><p>这两种同时起作用，就会让人一直停留在“不去做也不太坏，做了也不见得有多好”的情境中，以至于他从来都没有机会去体验做到之后的好处。</p><p>就比如，多数人都知道控制好情绪的重要，但是多数人也没有因为情绪问题，而受过太大的伤害。或者体验到调整情绪带来的切实好处。平时在家里随意发脾气，家人之间最多是矛盾多一些，也没有让自己伤筋动骨，偶尔，哪天自己做好了，也没有及时收到家人的反馈和表扬，所以，也就随意为之了。然而，当真正危害到利益的时候，就不一样了，就如夫妻面临离婚，平时拿到的也开始去做了，因为“趋利避害”。</p><p>人的行动不是由知道驱动的，而是由欲望驱动。别人告诉你“你应该怎么做”这也只是道理，而道理是限于理性层面，只有自己真正集会道理背后可能带来的情绪体验或者切实利益，特此产生了欲望，才是“你想做的”。而很多人就是处于“别人说这么做有好处”的状态中。他自己并没有真正“想这么做”，所以，在听完一个道理完全没有实践的时候，就给自己一个结论说“臣妾做不到”。</p><h5 id="因为别人去做某事，这种事儿成功的概率很小"><a href="#因为别人去做某事，这种事儿成功的概率很小" class="headerlink" title="因为别人去做某事，这种事儿成功的概率很小"></a>因为别人去做某事，这种事儿成功的概率很小</h5><p>就好像“减肥”这件事！但是很多减肥失败，不是缺乏，而是因为他们并不觉得自己多胖。我们听到的胖，都是别人觉得我胖了，所以我就觉得，我要减肥。</p><p>再比如你自己很亲，但是看到别人都很忙，于是心里就想着！我不能被人落下，我也得找点事儿干，要不报个培训班吧！要不学个PPT吧！要不去个啥吧！</p><p>这个行为特别像小学的时候，看到隔壁家录制每天学习到11点，自己哪怕是打瞌睡，困得头都抬不起来，也要让台灯比他多亮半个小时才去睡，仿佛这样就战胜了他一样。</p><p>就好像去听一个讲座，看周围的人都 在奋笔疾书记录，自己却一脸懵逼不知道写啥，于是这时候只好把旁边的资料照着抄一下，因为大家都在写，我也总要写点什么吧!</p><p>因为大家都去做了，所以我也要做点什么，抱着这样目的出发，你不太容易会获得成绩。</p><h5 id="想清楚“我想做的，我适合做的，我应该做的”"><a href="#想清楚“我想做的，我适合做的，我应该做的”" class="headerlink" title="想清楚“我想做的，我适合做的，我应该做的”"></a>想清楚“我想做的，我适合做的，我应该做的”</h5><h6 id="我想做的"><a href="#我想做的" class="headerlink" title="我想做的"></a>我想做的</h6><p>这样的事情一旦真的行动起来，或许会有两种极端的结果：</p><blockquote><p>一种是，你做的特别投入，你研究的特别深入，然后成果也是一个接着一个。比如读书窝囊，有的人很容易上瘾和着迷，有息时间我特别迷恋时间管理的书，往往是读了一本之后，不会找到书里面提到的书，作者的其他书，以及这类型评价最高的书，完全有一种欲罢不能的快感。</p><p>另外一种是，其实很多事你真去做了，才发现和自己看到的不太一样，原来你看到的只是逐句，你一直潜意识没开始行动，也许不过 是意识到了你没天分，你吃不了这个苦，你压根、喜欢的确实不是这个东西本身，而只是表面。</p></blockquote><p>比如有的人说自己喜欢广告，但是可能他只是喜欢看广告，而未必是喜欢策划广告，一遍一遍地修改方案，甚至是去拍广告，所以抱着这种喜欢的想法进入广告公司，才发现怎么和自己的想象完全不一样？玻璃心彻底碎成了渣。</p><p>通常来说，我想做某事，是让你检视你自己热情的原点，也是验证你是否只是爱表面，而根本不是爱内容这件事。</p><p>所以，如果你还没找到你想做什么，别冒然开始，因为随随便便开始，也会随随便便结束。</p><h6 id="我适合做的"><a href="#我适合做的" class="headerlink" title="我适合做的"></a>我适合做的</h6><p>是基于你现在，毋的基础去做的提升，我已经有了一些画画基础，那要不要去报一个系统的学习班，让自己的爱好提高一个层次。</p><p>这部分更考验你的需求。就是：“你要不要，而不是别人给你的判断和建议”。因为很多的爱好延伸，专业的精进，短期之内是见不到成果的，从早到晚如果你能找到说服自己的理由，那你才会有继续的动力。</p><h6 id="我应该做的"><a href="#我应该做的" class="headerlink" title="我应该做的"></a>我应该做的</h6><p>这种是特别理性客观的分析，我目前的短板是什么？我要不要补齐，这点和减肥类似，它需要你意识到这是你的问题，而且你有足够大的想法去改变。</p><p>换句话说，你已经意识到肥胖对你有影响，而且你的血压、血糖、血脂老到了一个临界点，你必须要减肥了，你也不希望自己年纪轻轻就得上糖尿病，有一这样的想法，你才有可能去开始。</p><h4 id="哪些原因形成“道理都懂，但我就是做不到”"><a href="#哪些原因形成“道理都懂，但我就是做不到”" class="headerlink" title="哪些原因形成“道理都懂，但我就是做不到”"></a>哪些原因形成“道理都懂，但我就是做不到”</h4><p>这个普遍性问题共有六个主要原因。</p><h5 id="1-“懂”和“执行”之间没有必然联系"><a href="#1-“懂”和“执行”之间没有必然联系" class="headerlink" title="1. “懂”和“执行”之间没有必然联系"></a>1. “懂”和“执行”之间没有必然联系</h5><p>导致你行动的，不仅仅是懂。</p><p>在常规意义上和大众心理上，仿佛“懂得了”就等于一定可以做到。</p><p>当我们试图另一个人有所改变的时候，几乎所有用上的方法都是——【劝说】。仿佛只要把对方说通了，把他说明白了，他就能够做出改变了。</p><p>对于【一部分】说出“道理我都懂，但我做不到”的人而言，他们说出这句话某种意义上其实为了传达“你看，道理我明白了，但对我没有什么用，所以不要再试图令我改变了”。</p><p>另一方面，因为人们通常将懂得与执行挂勾，这就会在“知道，但做不到”</p><p>的情况下引发一定程度的焦虑。</p><h5 id="2-你懂的这个道理，可能带给你的结果，并不一定是你真正想要的"><a href="#2-你懂的这个道理，可能带给你的结果，并不一定是你真正想要的" class="headerlink" title="2.你懂的这个道理，可能带给你的结果，并不一定是你真正想要的"></a>2.你懂的这个道理，可能带给你的结果，并不一定是你真正想要的</h5><p>有非常多的人焦虑和痛苦是出于一种：笼统的渴望“变得更优秀”，“变得更好”之类，或是由于对别人的羡慕而将一些道理与方法套用在自己身上，但始终达不到目标所导致。</p><p>还有一些人是由于幼年时期被父母，老师，其他长辈给予很多高标准的评价和要求，导致其形成了一种会过度乞求完美和理想化的自我倾向。</p><p>比如，有许多出于考研阶段的人都非常的焦虑，一方面知道自己应该静下心来好好学习，另一方面，又总是会在该学习的时候不停地玩手机，刷微信刷微博浪费时间，日子一天天过去，内心也越来越着急，但行动却永远跟不上。于是他们就完全被焦虑和恐慌裹挟着，却从不能停下来想一想：我之所以考研其实会不会为了逃避找工作的压力？我之所以考研是不是只是想有个好大学研究生的名言、给自己镀一层金？我之所以考研会不会、只是父母的安排，而并不是我想要的。</p><h5 id="3-懂仅仅是止于理解"><a href="#3-懂仅仅是止于理解" class="headerlink" title="3. 懂仅仅是止于理解"></a>3. 懂仅仅是止于理解</h5><p>理解只是“理智性领悟”的开始，你还需要达到“情感性领悟”或称“有效性领悟”，尽管你在理智层面上“知道”了，但你的内心其实坚定相信的，还是之前的那种认知。</p><p>人类拥有理性，但问题在于，为我们做事情提供动力的并不是理智，而是情绪、情感、激情、憧憬等等……这些“感性”层面的要素。</p><p>所以从某种意义上讲，我们由分裂的两部分组成，理智与情感这两个部分时常会出现冲突。</p><p>比如非常多的人都在渴望着成功，这世上有非常多的人励志书籍在鼓励着人们去追求成功，也有不少的方法论告诉你怎样达到成功。</p><p>但不管你理智层面对成功多么的渴望，不管你多么清楚达到成功的步骤，但如果你无法发自内心的热爱这份事业，如果你不能在感性层面上对你所要做的事情充满激情，那么你毫无疑问会陷入懈怠和拖延，最终什么都做不了。</p><h5 id="4-喜欢舒适区"><a href="#4-喜欢舒适区" class="headerlink" title="4. 喜欢舒适区"></a>4. 喜欢舒适区</h5><p>知道了一个新的道理，想要达到一个新的改变，往往意味着你要跳出自己的舒适区，要经受一定程度的痛苦。</p><p>可我们不愿付出努力，不想承受痛苦，只想一觉醒来之后自己自动就改变了，只想着某一个未来的自己忽然就不再拖延了，只会一味地幻想自己年终的业绩，忽然就提到公司第一了。</p><p>但我们只会想，唑用幻想去满足自己，缓解焦虑，而很难在行动的层面付出任何有效的努力。</p><p>比如：“我知道我应该离开这个不爱我的男人，可我就是做不到”。</p><p>事实上并没有人拿着刀架在她的脖子上，告诉她要是离开这个男人我就砍死你，所以“可我就是做不到”这种说法本身就是一种逃避。</p><h5 id="5-人类本能的短视"><a href="#5-人类本能的短视" class="headerlink" title="5.人类本能的短视"></a>5.人类本能的短视</h5><p>事实上，一个月后，甚至一周后的自己，对我们而言都相当是“别人”，我们并不会在乎一周后没完成任务，没完成计划的那个你会有多痛苦。</p><p>你想到的是，只要“现在”自己爽，能够轻松就足够了，反正一周后的痛苦、挨骂、自责又不是“现在”的自己来承受。</p><h5 id="6-你懂的道理与你自身的认知系统和思维习惯存在着冲突"><a href="#6-你懂的道理与你自身的认知系统和思维习惯存在着冲突" class="headerlink" title="6.你懂的道理与你自身的认知系统和思维习惯存在着冲突"></a>6.你懂的道理与你自身的认知系统和思维习惯存在着冲突</h5><p>例如：“我知道你说的都是对的，但我还是无法接受”。</p><p>人的认知系统是一个逻辑严密、不同部分之间有着紧密联系的系统，但同时我们的许多谁知习惯和行为习惯，由于长期积累而各自为政。</p><p>没有一个标准让我们区分，没有一个标准供我们参考，我们无法做出拥有安全感的选择。但是，评判的标准太多，甚至几乎每一个人的评判标准都不一样，所以你会感到无所适从，你也无法确定哪一个选择对你更好，所以你就停留在犹豫和迟疑当中。</p><h4 id="如何做到知行合一"><a href="#如何做到知行合一" class="headerlink" title="如何做到知行合一"></a>如何做到知行合一</h4><h5 id="1-清除负面习惯"><a href="#1-清除负面习惯" class="headerlink" title="1. 清除负面习惯"></a>1. 清除负面习惯</h5><p>懒惰、悲观、敌视、依赖别人、极端这些对你阻碍最大的问题，或是与绝大多数道理经验、都不兼容的你自身的一些特点质。这些负面特质会成为你改变的最大阻碍。</p><h5 id="2-主动进行大量的学习与积累，扩大视野，加深洞察力"><a href="#2-主动进行大量的学习与积累，扩大视野，加深洞察力" class="headerlink" title="2. 主动进行大量的学习与积累，扩大视野，加深洞察力"></a>2. 主动进行大量的学习与积累，扩大视野，加深洞察力</h5><p>偏见与顽固的执念，往往是来自无知，不断地扩大知识面和视野，能够让你看待问题的时候，更加深入和全面。</p><h5 id="3-将自己调整到易于新知识的状态，建立开放式心态"><a href="#3-将自己调整到易于新知识的状态，建立开放式心态" class="headerlink" title="3. 将自己调整到易于新知识的状态，建立开放式心态"></a>3. 将自己调整到易于新知识的状态，建立开放式心态</h5><h5 id="4-逐渐地培养自己理智、主动的习惯"><a href="#4-逐渐地培养自己理智、主动的习惯" class="headerlink" title="4. 逐渐地培养自己理智、主动的习惯"></a>4. 逐渐地培养自己理智、主动的习惯</h5><h5 id="5-制定可执行计划"><a href="#5-制定可执行计划" class="headerlink" title="5. 制定可执行计划"></a>5. 制定可执行计划</h5><p>“具备可执行性”意味着你的计划是有效的。</p><p>没有可执行性的计划会让人丧气。</p><h5 id="6-持续练习，令新的观念逐渐替代旧的观念，新的行动逐渐代替旧的行动"><a href="#6-持续练习，令新的观念逐渐替代旧的观念，新的行动逐渐代替旧的行动" class="headerlink" title="6. 持续练习，令新的观念逐渐替代旧的观念，新的行动逐渐代替旧的行动"></a>6. 持续练习，令新的观念逐渐替代旧的观念，新的行动逐渐代替旧的行动</h5><p>持续的坚持才能带来深入扎实的改变。不仅是行动，包括认知习惯，也需要你有意识的自我提醒与矫正。</p><h4 id="什么才会让你改变"><a href="#什么才会让你改变" class="headerlink" title="什么才会让你改变"></a>什么才会让你改变</h4><p>经历。</p><p>只有自身的经历，才能够给予你最真实、最全面的感受和体会。</p>]]></content>
      
      <categories>
          
          <category> 为人处世 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 知易行难 </tag>
            
            <tag> 执行力 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>线性回归数学推导</title>
      <link href="/2018/06/20/%E7%BA%BF%E6%80%A7%E5%9B%9E%E5%BD%92%E6%95%B0%E5%AD%A6%E6%8E%A8%E5%AF%BC/"/>
      <url>/2018/06/20/%E7%BA%BF%E6%80%A7%E5%9B%9E%E5%BD%92%E6%95%B0%E5%AD%A6%E6%8E%A8%E5%AF%BC/</url>
      <content type="html"><![CDATA[<p>由样本数据，设</p><script type="math/tex; mode=display">y=\theta X+\epsilon</script><p>其中，y为真实值，X为原始数据矩阵，$\theta$ 为我们要求的最佳拟合参数向量。$\epsilon$ 为误差值。由于$\epsilon$ 符合正态分布，所以某一数据出现的概率为：</p><script type="math/tex; mode=display">P(y^i|x^i;\theta)={1\over{\sqrt{2\pi}\sigma}}exp(-{\epsilon^2 \over 2\sigma^2})={1\over{\sqrt{2\pi}\sigma}}exp(-{(y^i-\theta^Tx^i)^2 \over 2\sigma^2})</script><p>似然函数</p><p>我们要得到出现样本数据这个结果的概率，由联合概率公式：</p><script type="math/tex; mode=display">L(\theta)=\prod_{i=1}^m P(y^i|x^i;\theta)=\prod_{i=1}^m{1\over{\sqrt{2\pi}\sigma}}exp(-{(y^i-\theta^Tx^i)^2 \over 2\sigma^2})</script><p>取对数似然：</p><script type="math/tex; mode=display">ln(L(\theta))=ln(\prod_{i=1}^m{1\over{\sqrt{2\pi}\sigma}}exp(-{(y^i-\theta^Tx^i)^2 \over 2\sigma^2}))</script><p>由对数公式，得：</p><script type="math/tex; mode=display">ln(L(\theta))=\sum_{i=1}^m ln({1\over{\sqrt{2\pi}\sigma}}exp(-{(y^i-\theta^Tx^i)^2 \over 2\sigma^2})) \\=m*ln({1\over{\sqrt{2\pi}\sigma}})-{1\over{\sigma^2}}*{1\over 2}*\sum_{i=1}^m(y^i-\theta^Tx^i)^2</script><p>上面这个式子，前面一部分是正数，方差是已知的，于是我们只要求后面的目标函数。只要目标函数越大，似然函数就越小。</p><p>目标函数</p><script type="math/tex; mode=display">J(\theta)={1\over 2}\sum_{i=1}^m (h_\theta(x^i)-y^i)^2={1\over2}(X\theta-y)^T(X\theta-y)</script><p>求偏导：</p><script type="math/tex; mode=display">\Delta_\theta J(\theta)=\Delta_\theta({1\over2}(X\theta-y)^T(X\theta-y))=\Delta_\theta({1\over2}(\theta^TX^T-y^T)(X\theta-y)) \\=\Delta_\theta({1\over2}(\theta^TX^TX\theta-\theta^TX^Ty-y^TX\theta+y^Ty)) \\={1\over2}(2X^TX\theta-X^Ty-(y^TX)^T) \\=X^TX\theta-X^Ty</script><p>令上面的偏导为0,得：</p><script type="math/tex; mode=display">\theta=(X^TX)^{-1}X^Ty</script><p>通过已知的数据集，我们可以通过上面的公式求得参数向量。</p>]]></content>
      
      <categories>
          
          <category> 人工智能 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 线性回归 </tag>
            
            <tag> 机器学习 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>新立项开发方案讨论</title>
      <link href="/2018/06/20/%E6%96%B0%E7%AB%8B%E9%A1%B9%E5%BC%80%E5%8F%91%E6%96%B9%E6%A1%88%E8%AE%A8%E8%AE%BA/"/>
      <url>/2018/06/20/%E6%96%B0%E7%AB%8B%E9%A1%B9%E5%BC%80%E5%8F%91%E6%96%B9%E6%A1%88%E8%AE%A8%E8%AE%BA/</url>
      <content type="html"><![CDATA[<h3 id="文档说明"><a href="#文档说明" class="headerlink" title="文档说明"></a>文档说明</h3><h4 id="文档目标"><a href="#文档目标" class="headerlink" title="文档目标"></a>文档目标</h4><p>本文档针对新立项的开发需求，讨论开发模式与建表技术方案。本文档具有文档作者的某些倾向性认同方案。希望其他同事不受文档作者倾向性的影响，提出不同的意见，便于制订最佳方案。</p><h4 id="文档信息"><a href="#文档信息" class="headerlink" title="文档信息"></a>文档信息</h4><div class="table-container"><table><thead><tr><th style="text-align:center">文档作者</th><th style="text-align:center">更新日期</th><th style="text-align:left">更新信息</th><th style="text-align:left">备注</th></tr></thead><tbody><tr><td style="text-align:center">李清泉</td><td style="text-align:center">2018-06-16</td><td style="text-align:left">新文档撰写</td><td style="text-align:left">本方案是草稿方案</td></tr></tbody></table></div><h3 id="建表方案讨论"><a href="#建表方案讨论" class="headerlink" title="建表方案讨论"></a>建表方案讨论</h3><p>新的立项与云南立项的字段大同小异，这里有两种建表方式：</p><blockquote><ol><li>在原有立项表结构基础上，增加一些字段。</li><li>全新建表。</li></ol></blockquote><p>下面详细论述这两套方案的优缺点。</p><h4 id="在原有立项表结构基础建表"><a href="#在原有立项表结构基础建表" class="headerlink" title="在原有立项表结构基础建表"></a>在原有立项表结构基础建表</h4><p>广东的立项的表单与原来云南立项的表单大同小异。我们当然可以共用原来的表结构，在原来的基础上做一些拓展。</p><h5 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h5><ol><li>减少数据库的复杂度。这样建表的目标是在业务上我们将广东的立项跟原来的立项不做区分，我们认为广东的立项只是原来业务基础上新增加的需求。模块是一样的。</li><li>方便做统计功能。如果采用两套不同的表，做统计时只能使用union all的方式，SQL语句比较复杂。</li></ol><h5 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h5><ol><li>必须修改原来的代码逻辑，风险高。</li><li>业务逻辑耦合度高，区分复杂，不利于以后的业务扩展。</li><li>不利于新员工学习理解。</li></ol><h4 id="全新建表"><a href="#全新建表" class="headerlink" title="全新建表"></a>全新建表</h4><p>全新建表，就是这次的广东立项需求我们建一套完全全新的表体系，数据跟之前的数据完全不混合。</p><h5 id="优点-1"><a href="#优点-1" class="headerlink" title="优点"></a>优点</h5><ol><li>代码、业务耦合度低。我们可以将这次的需求理解成为一个全新的业务模块，完全不受之前立项模块的影响，从新写代码。</li><li>不需要对原来模块的代码做任何修改，风险低。</li><li>以后如果有立项的需求，可以完全按现有的方式开发，扩展性强。</li><li>有利于新员工的学习。业务、代码的耦合会让新人理解起来麻烦。</li><li>不同地区的数据分开存储，性能有一定提升。</li></ol><h5 id="缺点-1"><a href="#缺点-1" class="headerlink" title="缺点"></a>缺点</h5><ol><li>表的数量多，增加数据库复杂度。</li><li>增加建表工作量。</li><li>做统计功能时，如果涉及到所有立项的数据，必须使用union 语句，SQL语句复杂度高。</li></ol><h3 id="开发模式讨论"><a href="#开发模式讨论" class="headerlink" title="开发模式讨论"></a>开发模式讨论</h3><p>新立项的开发模式和设计上，有两种方案可以选择：</p><blockquote><ol><li>使用微服务模式。</li><li>在双创现有代码上，增加一个模块。</li></ol></blockquote><p>下面讨论一下这两种方案的区别和优缺点。</p><h4 id="微服务开发模式"><a href="#微服务开发模式" class="headerlink" title="微服务开发模式"></a>微服务开发模式</h4><p>微服务的开发模块就是我们按照新框架的开发规范，新增加一个微服务，在这个微服务模块上开发新的广东立项的逻辑。</p><h5 id="优点-2"><a href="#优点-2" class="headerlink" title="优点"></a>优点</h5><ol><li>给我们开发人员实践新框架的机会，加快开发人员熟悉新框架开发规范。</li><li>完全体现了新框架的优势：扩展性强，可维护性强，代码耦合度低。</li><li>有利于新员工理解。</li><li>运维方便。广东立项版本发布不受大版本旧系统的影响。</li></ol><h5 id="缺点-2"><a href="#缺点-2" class="headerlink" title="缺点"></a>缺点</h5><ol><li>新框架的开发模式还没有在开发人员身上理解深刻，上线新框架的开发模式有些仓促。</li><li>搭建框架需要一定的时间，有风险。</li><li>正式环境还没有准备好全面新框架的上线条件，存在风险。</li><li>客户还没有同意这种全新的部署方式。</li><li>需要跟进硬件资源。</li><li>运维人员还没有熟悉新框架的运维方式，需要他们有熟悉的过程。存在一定风险因素。</li></ol><h4 id="原有系统新增模块"><a href="#原有系统新增模块" class="headerlink" title="原有系统新增模块"></a>原有系统新增模块</h4><p>原有双创项目上新增模块，就是按照以前的开发模式，采用保守的方法，新增一个代码模块进行开发。</p><h5 id="优点-3"><a href="#优点-3" class="headerlink" title="优点"></a>优点</h5><ol><li>按照大家熟悉的模式进行开发，风险低。</li><li>框架没有发生改变，旧的标签都可以一样使用，不需要另外产生开发工作量。</li><li>不产生接口工作量。</li><li>不需要考虑客户部署申请等工作要求。</li></ol><h5 id="缺点-3"><a href="#缺点-3" class="headerlink" title="缺点"></a>缺点</h5><ol><li>该方案过于保守。即使在新框架开发接近可使用的基础上，仍然使用原有的开发模式。</li><li>不利于开发人员熟悉新框架的开发模式。损失了一次锻炼的机会。</li><li>不能体现出新框架的优势。</li></ol><h4 id="考虑方式"><a href="#考虑方式" class="headerlink" title="考虑方式"></a>考虑方式</h4><ol><li>对风险的评估。特别是对开发时间的评估，采用微服务的开发模式的工作量要超过采用增加新模块的开发模式。但不会超过很多。</li><li>广东立项模块的重要程度。</li><li>如果采用新框架微服务的开发模式，要求事先有合理的风险回避方案。</li></ol><h3 id="采用微服务开发模式的风险回避方案"><a href="#采用微服务开发模式的风险回避方案" class="headerlink" title="采用微服务开发模式的风险回避方案"></a>采用微服务开发模式的风险回避方案</h3><p>采用新框架的开发模式，会产生更高的风险，我认为可以考虑以下的点：</p><blockquote><ol><li>对新框架开发模式工作量和大家的适应时间应作出合理的评估</li><li>在采用微服务开发模式的情况下，如果出现风险，应该如何解决？</li><li>结合两种开发模式回避风险</li></ol></blockquote><h4 id="作出合理的评估"><a href="#作出合理的评估" class="headerlink" title="作出合理的评估"></a>作出合理的评估</h4><p>大家应充分发表意见。充分列出可能产生风险的地方，以方便大家对可能出现的问题有合理的预防和评估。</p><h4 id="有合理的回避风险的方法"><a href="#有合理的回避风险的方法" class="headerlink" title="有合理的回避风险的方法"></a>有合理的回避风险的方法</h4><p>比如以下的方法有助于解决困境：</p><ol><li>如果三天新框架不能正常跑起来，应放弃采用新框架的开发模式，回归原来的开发模式。</li><li>大家不能适应新框架开发模式时，应回归原来的开发模式。</li><li>大家发现新框架的开发模式明显增加工作量且无法解决，影响到新版本发布时，应该放弃这种开发模式。</li></ol><h4 id="结合两种开发模式"><a href="#结合两种开发模式" class="headerlink" title="结合两种开发模式"></a>结合两种开发模式</h4><p>我认为两种开发模式并不是完全冲突且不能有任何兼容的。以下方法是回避风险的有效方法：</p><ol><li>在搭建新的微服务模块的同时，其他开发人员可以在原有的系统上新增模块采用原有的模式写代码。</li><li>新框架如果可以顺利搭建，将代码从旧系统上复制过来并按照新框架模式进行开发。</li><li>同样，采用新模式遇到不可解决的风险时，也可以将业务代码复制到原有的系统继续开发。</li><li>开发模块，大家应注意尽量不要耦合其他模块的业务代码，造成分割困难。</li></ol>]]></content>
      
      <categories>
          
          <category> 架构方案 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 方案讨论 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>K近邻算法详解</title>
      <link href="/2018/06/19/K%E8%BF%91%E9%82%BB%E7%AE%97%E6%B3%95%E8%AF%A6%E8%A7%A3/"/>
      <url>/2018/06/19/K%E8%BF%91%E9%82%BB%E7%AE%97%E6%B3%95%E8%AF%A6%E8%A7%A3/</url>
      <content type="html"><![CDATA[<p>本文打算简单介绍K近邻算法。不展开论述。</p><h3 id="K近邻算法概述"><a href="#K近邻算法概述" class="headerlink" title="K近邻算法概述"></a>K近邻算法概述</h3><blockquote><p>举个例子：</p><p>如果你想知道170厘米身高的人体重是多少。最好的办法是不是从一堆人当中找到几个身高最接近170厘米的人，称出他们的体重然后算平均值呢？</p></blockquote><p>事实上，K近邻就是这样简单。所谓“K”，就是找最接近估算值的K个元素然后算平均值。</p><p>设我们有一堆数据：</p><div class="table-container"><table><thead><tr><th>性别</th><th>身高</th><th>胖瘦(目测)</th><th>体重</th></tr></thead><tbody><tr><td>男</td><td>171</td><td>胖</td><td>65</td></tr><tr><td>女</td><td>167</td><td>瘦</td><td>59</td></tr><tr><td>男</td><td>170</td><td>瘦</td><td>63</td></tr></tbody></table></div><p>现在我们要估测下面一个人的体重：男，169，胖。怎么测呢？我们如果只看身高，女生也有170的人，但明显女生的数据不太符合我们的要求，还有胖瘦也应该符合要预测的数据才行。所以，我们应该用N维的近邻估测。即ML-KNN。</p><h3 id="数据标准化"><a href="#数据标准化" class="headerlink" title="数据标准化"></a>数据标准化</h3><p>这里必须先介绍数据标准化的概念。上面的数据，性别只有男女，即可以改为1，0，胖瘦也是一样，而身高变化的范围却很大。当我们使用算法时某一些字段可能影响过大而造成“不公平”。设$\mu$ 为某字段的均值，$\sigma$ 为对应标准差，数据标准化的公式为：</p><script type="math/tex; mode=display">{ {x- \mu} \over \sigma}</script><p>数据标准化后，所有字段都会转化为以0为对称中心的数据，消除了比例差异。</p><h3 id="欧氏距离"><a href="#欧氏距离" class="headerlink" title="欧氏距离"></a>欧氏距离</h3><p>可以使用欧氏距离计算ML-KNN的多维距离。</p><script type="math/tex; mode=display">d= {1 \over n} \sum_{i=1}^n(p_i-q_i)^2</script><script type="math/tex; mode=display">\sqrt{d}</script><p>其中,p,q为相应两条数据的对应字段。(博客有问题，无法解析根号)</p><h3 id="N维K近邻"><a href="#N维K近邻" class="headerlink" title="N维K近邻"></a>N维K近邻</h3><p>将表格中所有字段进行标准化处理后，再应用欧氏距离公式算出每条样本数据与要估算的数据的值。然后进行排序，找出距离最近的K条数据，然后对这几条数据的体重算平均值。</p>]]></content>
      
      <categories>
          
          <category> 人工智能 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> -K近邻 -机器学习 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>美国是否可能走向独裁</title>
      <link href="/2018/06/18/%E7%BE%8E%E5%9B%BD%E6%98%AF%E5%90%A6%E5%8F%AF%E8%83%BD%E8%B5%B0%E5%90%91%E7%8B%AC%E8%A3%81/"/>
      <url>/2018/06/18/%E7%BE%8E%E5%9B%BD%E6%98%AF%E5%90%A6%E5%8F%AF%E8%83%BD%E8%B5%B0%E5%90%91%E7%8B%AC%E8%A3%81/</url>
      <content type="html"><![CDATA[<p>美国建国已经200多年了，如果美国会走向帝制，为什么直到现在仍然没有这个迹象呢？美国建国之初，所有的政治精英没有一个是希望美国成为帝制国家的，相反，他们非常害怕美国会最终成为一个独裁国家。</p><p>美国建国之初有非常好的民主条件。</p><ul><li>美国是一个“没有历史”的国家，美国人民根本没有根深蒂固的专制思想。</li><li>美国建国之初，各邦互相独立。没有所谓的“中央”。</li><li>美国建国之初，各邦的领导人有思想，有文化，赞成民主。</li><li>各邦领导人希望和平解决大家之间的利益分配问题。最终认同统一的宪法和联邦制。</li></ul><p>政治制度具有稳定性，良性循环的制度最终良性作用于社会。美国人民对美国制度具有高度的认同感，他们最害怕的就是独裁。他们在制度和教育等各方面想尽办法防止政府走向专制：</p><ol><li>国家根本制度采用宪政民主，只有一部宪法。美国人民对法具有高度认同，“人情”处于次要地位。</li><li>国家根本制度是三权分立。没有一个政府官员有权力独裁，也不具有这种可能性。</li><li>军队的指挥权虽然属于总统，但总统不能直接指挥军队。总统只有在国会同意下才有战争权。军队的各级领导人对宪政和国家根本制度高度认同，总统无法指挥军队做出越权的事情。其实，美国总统只有战略的军队指挥权，没有战术的军队指挥权。总统不可能直接命令前线军队的，他只是任免军队的指挥官而已。美国总统发布军事命令时，必须通过参谋长联席会议，美国有一套完整的机制。美国总统只能直接调动海军陆战队，但这些小部队不足以让他独裁。所以，美国总统没有独裁的可能性。</li><li>美国的教育崇尚自由、独立思考，美国人没有官本位思想。官员们也可以正确看待权力，很少有人迷恋权力。美国人并不认为成为政府领导人是一个非常了不起的事情。竞选各级领导的人基本只是为了证明他的能力，很少是因为获得权力。美国官员并不好做，有同样能力的大部分人都没有兴趣。</li></ol><p>这样的国家可能走向专制独裁吗？</p>]]></content>
      
      <categories>
          
          <category> 政治历史 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> -美国 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>数据模型设计范式</title>
      <link href="/2018/06/18/%E6%95%B0%E6%8D%AE%E6%A8%A1%E5%9E%8B%E8%AE%BE%E8%AE%A1%E8%8C%83%E5%BC%8F/"/>
      <url>/2018/06/18/%E6%95%B0%E6%8D%AE%E6%A8%A1%E5%9E%8B%E8%AE%BE%E8%AE%A1%E8%8C%83%E5%BC%8F/</url>
      <content type="html"><![CDATA[<p>先讲一个知识：外键一定要建索引。</p><h5 id="第一范式"><a href="#第一范式" class="headerlink" title="第一范式"></a>第一范式</h5><p>数据表中的任何一个字段都是不可拆分的。不要把多个信息存储在同一个字段之中。</p><h5 id="第二范式"><a href="#第二范式" class="headerlink" title="第二范式"></a>第二范式</h5><p>请先确定数据表中的决定与被决定关系。比如：医院编号决定了医院名称、类型、地址等。因为知道了编号已经可以唯一确定这些信息了。通过第二范式我们可以拆分出不包含冗余信息的表。</p><p>第二范式（2NF）要求实体的属性完全依赖于主关键字。所谓完全依赖是指不能存在仅依赖主关键字一部分的属性，如果存在，那么这个属性和主关键字的这一部分应该分离出来形成一个新的实体，新实体与原实体之间是一对多的关系。为实现区分通常需要为表加上一个列，以存储各个实例的惟一标识。简而言之，第二范式就是属性完全依赖于主键。</p><p>如果数据表的设计不符合第二范式，一方面会造成数据冗余，另一方面会让数据的更新造成麻烦，因为我们必须同时更新多个地方才可以确保所有包含同一个信息的数据同步。</p><h5 id="第三范式"><a href="#第三范式" class="headerlink" title="第三范式"></a>第三范式</h5><p>属性不依赖于其它非主属性[消除传递依赖]。</p><p>满足第三范式（3NF）必须先满足第二范式（2NF）。简而言之，第三范式（3NF）要求一个数据库表中不包含已在其它表中已包含的非主关键字信息。例如，存在一个部门信息表，其中每个部门有部门编号（dept_id）、部门名称、部门简介等信息。那么在的员工信息表中列出部门编号后就不能再将部门名称、部门简介等与部门有关的信息再加入员工信息表中。如果不存在部门信息表，则根据第三范式（3NF）也应该构建它，否则就会有大量的数据冗余。简而言之，第三范式就是属性不依赖于其它非主属性。</p><blockquote><p><strong>【注意】</strong>不可以因为贪图方便在表中故意放冗余字段</p><p>比如：明知道部门表中已经有了部门名称的字段，但是，为了避免在用户表中联表才可以查询出部门名称，就把部门名称写到了用户表中。这样做好像不需要联表查询了，单表就可以查询出部门名称，但会造成其他问题。</p></blockquote>]]></content>
      
      <categories>
          
          <category> 数据库 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据模型 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>极大似然函数简单解释</title>
      <link href="/2018/06/11/%E6%9E%81%E5%A4%A7%E4%BC%BC%E7%84%B6%E5%87%BD%E6%95%B0%E7%AE%80%E5%8D%95%E8%A7%A3%E9%87%8A/"/>
      <url>/2018/06/11/%E6%9E%81%E5%A4%A7%E4%BC%BC%E7%84%B6%E5%87%BD%E6%95%B0%E7%AE%80%E5%8D%95%E8%A7%A3%E9%87%8A/</url>
      <content type="html"><![CDATA[<p>极大似然函数花了我好多时间理解。我觉得很有必要写一篇博文解释一下。虽然网上有关的博客很多，但大多数都写得过于复杂，我想解释得简单一些。</p><h2 id="举栗子是最好的方法"><a href="#举栗子是最好的方法" class="headerlink" title="举栗子是最好的方法"></a>举栗子是最好的方法</h2><p><a href="https://www.zhihu.com/question/54082000/answer/137868083" target="_blank" rel="noopener">如何理解似然函数? - 陈琳的回答 - 知乎</a></p><p>引用知乎上这位朋友的回答，再扩展一下。</p><p>我也假设有一个特殊的骰子，不知道有多少面。我们知道一般骰子都是6面，但我这里的骰子面数未知，是特制的。现在我们拿这个骰子抛了1000次，其中我们发现其中“1”的这一面出现了100次。当然按照直觉我们认为这个骰子最有可能是10个面，但是怎么用数学证明出来呢？如果我们经过大量的实验知道了某件事情的结果，想要反过来推测这件事情发生的概率，那么这个推测就称为极大似然估计。</p><p>设这个骰子有N面，所以出现“1”面的概率就是${1 \over N}$。根据联合概率计算公式，发生1000次抛骰子而有100次某个面向上这个结果的概率为：</p><script type="math/tex; mode=display">P=({1 \over N})^{100}  (1-{1\over N})^{900}</script><p>那么，怎么求出N呢？所谓最大似然，是指N最有可能是什么。在这个函数里面，最有可能是不是说对函数P求导，只要求出导数为0那个N值就可以了？当导数为0时我们可以求出P的极值点。即，我们要求P的导数$P’$为0的情况。</p><p>但是，上面那个式子的导数不好求啊，900次方了都。但是，数学家们很聪明，他们发现对幂数函数取对数不会改变函数的单调性。设$y=f(x)$，那么，$ln(f(x))$的单调性与$f(x)$的单调性一样。即：$f’(x)$与$(ln(f(x)))’$的极值点是一样的。</p><p>于是，我们对P取对数：</p><script type="math/tex; mode=display">ln(P)=ln(({1 \over N})^{100}  (1-{1\over N})^{900})=100ln{1\over N}+900ln(1-{1\over N})</script><p>对数公式就不解释啦，这个可以百度。对数真是一个神奇的东西，可以把这么复杂的幂函数化简成这个样子。补充数学公式：</p><blockquote><ol><li><p>$ln(ab)=lna+lnb$</p></li><li><p>$ln(a^b)=blna$</p></li><li><p>$(lnx)’={1\over x}$</p></li><li><p>$(x^n)’=nx^{n-1}$</p></li><li><p>复合函数$f(g(x))$的导数为：</p><script type="math/tex; mode=display">f'(g(x))=g'(x)*f'(g(x))</script></li></ol></blockquote><p>所以：</p><script type="math/tex; mode=display">(ln(P))'=(100ln{1\over N}+900ln(1-{1\over N}))'=100*N*-1*{1\over N^2}+900*{N\over {N-1}}*{1\over N^2}</script><script type="math/tex; mode=display">(ln(P))'=900({1\over {N(N-1)}})-100{1\over N}</script><p>令$(ln(P))’=0$，得：</p><script type="math/tex; mode=display">900({1\over {N(N-1)}})=100{1\over N}</script><p>即：</p><script type="math/tex; mode=display">900{1\over{N-1}}=100</script><p>这是初中的方程哦，我们可以得出：</p><script type="math/tex; mode=display">N=10</script><p>所以，这个骰子最有可能有10个面。问题得解。</p>]]></content>
      
      <categories>
          
          <category> 人工智能 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 极大似然 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>第一阶段总结与承诺</title>
      <link href="/2018/06/10/%E7%AC%AC%E4%B8%80%E9%98%B6%E6%AE%B5%E6%80%BB%E7%BB%93%E4%B8%8E%E6%89%BF%E8%AF%BA/"/>
      <url>/2018/06/10/%E7%AC%AC%E4%B8%80%E9%98%B6%E6%AE%B5%E6%80%BB%E7%BB%93%E4%B8%8E%E6%89%BF%E8%AF%BA/</url>
      <content type="html"><![CDATA[<h3 id="第一阶段总结"><a href="#第一阶段总结" class="headerlink" title="第一阶段总结"></a>第一阶段总结</h3><p>其实，我对我们个人敏捷的关注度不是很高。最近我忙于技术进修，对于个人敏捷的活动并不是非常关注，只是在交作业的时候做一下。还有一次班长要求我做录音讲解，那一次我是比较认真的。</p><p>我觉得我这样子主要是两方面的原因：</p><h4 id="我这次进修很重要，需要投入100-的精力"><a href="#我这次进修很重要，需要投入100-的精力" class="headerlink" title="我这次进修很重要，需要投入100%的精力"></a>我这次进修很重要，需要投入100%的精力</h4><p>我出来工作有好几年了，年龄大了以后就开始有各种想法，之前对于自己的了解不够，尝试过做管理，尝试过其他行业。后来终于发现自己其实还是喜欢技术，我是一个希望用技术改变世界的人。</p><p>我觉得我现在从事的技术工作对社会改变很有限，AI大热以后，我感觉人工智能可以改变世界，于是我现在一心投入到其中进行学习了。</p><p>人工智能需要的数学知识比较多，入门门槛很高，所以我真的有些顾不上我们的个人敏捷活动了。但是，我还是花时间留意大家的行动，从周老师的课程也获知到，自我管理是个人技能的重要维度，我不能退出个人敏捷的学习。只是暂时可能不能作为重点关注了。</p><h4 id="我之前认真研究过心理学，个人敏捷的理论跟我之前的学习有一定的重叠之处"><a href="#我之前认真研究过心理学，个人敏捷的理论跟我之前的学习有一定的重叠之处" class="headerlink" title="我之前认真研究过心理学，个人敏捷的理论跟我之前的学习有一定的重叠之处"></a>我之前认真研究过心理学，个人敏捷的理论跟我之前的学习有一定的重叠之处</h4><p>在加入个人敏捷之前，因为个人人际关系不和谐等各种原因，我曾经花了很多时间研究人际关系、心理学、情商等知识。加入个人敏捷群后，我发现个人敏捷的许多内容跟我之前研究的内容有重叠之处。所以，在这一点上说，我确实对我们的活动有一点放松。但是，我对个人敏捷是非常重视的。我会认真思考我们个人敏捷里面的每一个活动。</p><p>我们的第二阶段的内容主要是情绪管理。这也是我非常重视和乐于参与的内容。</p><p>之前，我的人际关系紧张，主要是自我情绪管理不好。一方面容易发脾气，另一方面说话时带情绪，让对方感到不舒服。</p><p>我们应该好好理解自己的情绪和别人的情绪。第一，我们只有正确理解了人性，才会感到幸福。第二，只有在情绪管理方面做好，我们的人际关系才和谐。第三，只有在情绪管理上面做好，才可以使自己能力提升，具备领导和管理团队的能力，也才可以有正确决策的能力。</p><p>情绪是一个长期的自我斗争的过程。三年前，我就开始接触心理学和人际交往相关课程了，但是，前几周我还因为情绪管理不好和领导争吵，差一点导致严重的后果。这件事也使我深深感觉到情绪管理的不易。</p><p>从心理学理论我们了解到，情绪是快于理智的。当我们感觉到威胁、不安等情境时，杏仁体会迅速发生作用，劫持我们的大脑，导致愤怒情绪的发生，于是下面就容易发生不愉快的事情。很多时候我们其实知道情绪是不对的，我们也许事后会后悔，但是，想在杏仁体发生作用前夺取大脑的控制权很难！</p><p>所以，我期望和大家一起进入情绪管理阶段的学习。如果我们不断和杏仁体劫持做斗争，相信终有一天我们在这方面会做得很好。</p><p>司马迁说过一句话：“夫勇者,卒然临之而不惊,无故加之而不怒.泰山崩于前而色不变,麋鹿行于左而目不瞬”。说的是做大事的人都有良好的情绪控制能力，遇到大事前，不会慌慌张张，不会被情绪左右自己，而是会冷静地处理。</p><h4 id="曾国藩是一个好榜样"><a href="#曾国藩是一个好榜样" class="headerlink" title="曾国藩是一个好榜样"></a>曾国藩是一个好榜样</h4><p>没有人一开始就可以做得很好。这几年，我们听到很多人都推崇一个人：曾国藩。他最大的成就就是在清朝对太平军束手无策的情况下，领导湘军屡败屡战，最终帮助清朝将太平天国镇压下去，官至极品。可是，曾国藩并不是一开始就是一个有大才的人。30岁之前，曾国藩其实是一个很平凡的人。他在自己的日记里面写道，他爱玩，喜欢炫耀学问，脾气大，还好色。并且多次在日记中痛斥自己的不当行为。即使曾国藩对自己要求很严格，他的朋友在他年轻的时候也从来没有觉得他有什么了不起，他的另一个同事胡林翼根本就看不起他，不想跟他来往。</p><p>创办湘军后，曾国藩也没有一开始就能做好。他曾经因为打败仗而要跳水自杀；曾经因为皇帝不重用而一气之下自己跑回老家丢下湘军不理了。</p><p>但是，曾国藩有一个很大的优点，他懂得反思，懂得改变。他每次受挫后一开始尽管也心情低落，但他总能吸取教训，并改正错误。一次一次碰壁后，他的情绪控制能力越来越好，脾气也越来越小了。有一句话叫做“宰相肚里能撑船”，后期的曾国藩也真的做到了。曾国藩有一个同事叫做左宗棠，这个人非常有才，但是脾气暴躁，而且也经常轻视曾国藩，认为曾国藩没有他厉害。他因为和曾国藩有过一些摩擦而毕生不太尊重曾国藩，经常在别的官员面前说他的坏话。然而曾国藩从来不放在心上。后来左宗棠要去打仗，缺粮食，曾国藩想都没想就给左筹到了，完全没有因为左宗棠的行为而在这件事上有所怠慢。在这件事可以看出，左宗棠在为人处世上不如曾国藩。</p><p>曾国藩的故事告诉我们，没有人一生下来就是圣人。无论多么优秀的人，都是在不断努力不断吸取教训之中走过来的，我们没有理由因为自己做得不够好而责怪自己。只要我们不断地改正自己的不良行为，总有一天也会像曾国藩一样成为大家尊重的人。</p><h3 id="承诺"><a href="#承诺" class="headerlink" title="承诺"></a>承诺</h3><p>最后我说说我对承诺的理解。</p><p>承诺是这周我们个人敏捷活动的主题。承诺的关键是我们要讨论如果我们对其他人做过某些承诺，我们做事情往往会更有责任心，做得更好。</p><p>我非常认可这个观点。我个人的经验也印证了这个观点。生活中，我是一个比较懒散的人，比较随意，宿舍往往乱得一塌糊涂。可是一旦答应了别人什么事情，从来不敢怠慢，主要是怕别人看不起自己，怕成为别人眼里那种不靠谱的人。</p><p>从这一点上看，其实我们可以利用人类的这个特点，请朋友监督自己。</p><p>如果我们想养成某一个好习惯，光靠自己努力往往事倍功半。因为我们对自己总是自律力不强的。但是如果我们承诺了朋友什么事情，效果往往会好很多。所以，我们为了向朋友有好的交代，一定会更加认真地做。上一次，我因为发脾气非常后悔，又怕自己以后轻易再犯，于是请一个朋友监督，承诺如果我以后又轻易发脾气，就请他吃三次饭。果然直到现在，我都做得挺好。</p><p><strong>重承诺，不要成为别人眼里不靠谱的人</strong></p><p>长辈总是教导我们，要讲信用。这句话是很有道理的。如果我们总是辜负别人的期望，别人还有什么理由相信我们呢？这样我们还能做什么大事呢？生活中我们眼里那些不成器的人往往就是这样形成的。</p><p>我今周的作业就讲到这里，希望能跟大家继续学习。</p>]]></content>
      
      <categories>
          
          <category> 个人敏捷 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 承诺 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>PCA数学原理理解</title>
      <link href="/2018/06/10/PCA%E6%95%B0%E5%AD%A6%E5%8E%9F%E7%90%86%E7%90%86%E8%A7%A3/"/>
      <url>/2018/06/10/PCA%E6%95%B0%E5%AD%A6%E5%8E%9F%E7%90%86%E7%90%86%E8%A7%A3/</url>
      <content type="html"><![CDATA[<p>本文讨论对PCA数学原理的理解。</p><p>原文中最难理解的是：</p><ol><li>协方差矩阵的特征向量为什么是原始数据的降维方向？</li><li>协方差矩阵为什么可以并且要对角化？</li></ol><p>这两个问题其实是一个问题。</p><p>我们知道，协方差矩阵是一个对称矩阵，即：</p><script type="math/tex; mode=display">CC^T=C^TC</script><p>线性代数中，任何一个实对称矩阵，都有这样的特征：</p><blockquote><ol><li><p>它的特征向量一定正交。</p></li><li><p>特征向量单位化后组成的矩阵一定可以将原对称矩阵对角化。即：</p><script type="math/tex; mode=display">E^T C E=\Lambda</script></li></ol></blockquote><p>请理解我们要解决的根本问题：我们的目标是求得一个矩阵P，使Y=PX，最终结果是Y尽可能保留原数据的特征。那么，在数学上说，是不是我们要求得一个矩阵P，使得变换后的数据矩阵Y的协方差矩阵D不同维度的协方差为0？只要不同维度的协方差为0，那么不同的维度是不是相互独立，互不影响了呢？这样一来，重复的维度又不大重要的维度都被去掉了！</p><p>那么，上面的协方差为0，不就是一个对角矩阵$\Lambda$嘛！对角矩阵除了了对角线的元素之外，其他元素都是0. 正好满足了我们要求的目标。</p><p>上面我们知道，原始数据X虽然不对称，但它的协方差矩阵C是对称的，设C的特征向量矩阵为E，于是：</p><script type="math/tex; mode=display">E^TCE=\Lambda</script><p>我们还需要推导另一个关系,设D为Y的协方差矩阵，有：</p><script type="math/tex; mode=display">D={1 \over m}YY^T={1 \over m}(PX)(PX)^T={1 \over m}PXX^TP^T=P({1 \over m}XX^T)P^T=PCP^T</script><p>我们的目标是令D成为一个对角矩阵。于是：</p><script type="math/tex; mode=display">D=\Lambda=PCP^T=E^TCE</script><p>$E^T$就是我们最终要求的结果。即：$P=E^T$。</p><p>所以：</p><script type="math/tex; mode=display">Y=PX=E^TX</script><p>我们知道，X是已知的，于是我们可以求得对应的协方差矩阵C，通过C可以求特征向量矩阵$E^T$，从而求得对应的对角矩阵$\Lambda$。而事实上，$\Lambda$就是特征向量矩阵对应的对角为特征值的对角矩阵。我们按照特征值大小排序就是可以去掉特征值特别小的特征向量了。所以P是我们去掉一些特征后的最终结果。</p>]]></content>
      
      <categories>
          
          <category> 人工智能 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> PCA </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>对上不对下，乃是祸害之源</title>
      <link href="/2018/06/10/%E5%AF%B9%E4%B8%8A%E4%B8%8D%E5%AF%B9%E4%B8%8B%EF%BC%8C%E4%B9%83%E6%98%AF%E7%A5%B8%E5%AE%B3%E4%B9%8B%E6%BA%90/"/>
      <url>/2018/06/10/%E5%AF%B9%E4%B8%8A%E4%B8%8D%E5%AF%B9%E4%B8%8B%EF%BC%8C%E4%B9%83%E6%98%AF%E7%A5%B8%E5%AE%B3%E4%B9%8B%E6%BA%90/</url>
      <content type="html"><![CDATA[<h2 id="知乎上的话题"><a href="#知乎上的话题" class="headerlink" title="知乎上的话题"></a>知乎上的话题</h2><blockquote><p> <a href="https://zhuanlan.zhihu.com/p/31956198" target="_blank" rel="noopener">政策为何会变样：治理国家的艰难之处</a></p><p><a href="https://www.zhihu.com/question/26984147/answer/269660715" target="_blank" rel="noopener">为什么历史上有名的重臣，他们学的四书五经，读的是圣贤书，都没有学数理化，照样把国家治理的很好？</a></p><p><a href="https://www.zhihu.com/question/20422670/answer/15096800" target="_blank" rel="noopener">为什么宦官「弄权」就一定会「败坏朝纲」</a></p></blockquote><p>我对第三个问题比较感兴趣，先讨论这个问题吧。</p><h2 id="讨论问题"><a href="#讨论问题" class="headerlink" title="讨论问题"></a>讨论问题</h2><h3 id="为什么宦官「弄权」就一定会「败坏朝纲」"><a href="#为什么宦官「弄权」就一定会「败坏朝纲」" class="headerlink" title="为什么宦官「弄权」就一定会「败坏朝纲」"></a>为什么宦官「弄权」就一定会「败坏朝纲」</h3><p>要讨论问题，应该先释义，再分析，最后解决。</p><h4 id="释义"><a href="#释义" class="headerlink" title="释义"></a>释义</h4><p>什么叫做“朝纲”？如果不先解释这个词语，我们讨论起来就容易乱。朝纲按照百度百科的解释，就是朝廷的法纪。因此，这个问题实质是“为什么太监专权就一定会破坏朝廷的法纪”。</p><h4 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h4><p>社会上人的大部分行为其实都可以解释为一个目的：<strong>趋利</strong>。</p><h5 id="太监为什么会专权"><a href="#太监为什么会专权" class="headerlink" title="太监为什么会专权"></a>太监为什么会专权</h5><p>太监专权，那么我们先分析一下太监为什么要专权。一个器官不全的人，放着正职不做，为什么要来干预皇家的事情？</p><p>原本太监只是皇宫里面干杂活的。皇帝身边除了妃子、侍卫之外，总要大量的人手服侍。其实服侍这种全部要女人也可以的，但无奈女人在生理上干不了重活。有一些事情非要男性才干得了。但是皇宫里面那种杂活通常要杂工一直住在里面，而且皇帝妃子们喜欢上一个工人了往往也一直留在身边。可这样一来，皇帝就容易戴绿帽子了。理论上，皇宫里面任何一个女人皇帝都可以要，也就是皇宫里面任何一个女人都可以看成皇帝的老婆，而皇帝又不能顾全到所有女人。要是这些女人身边有男人，不是太危险了吗？所以，这些干杂活的男人必须都得切了。</p><blockquote><p>题外话：为什么侍卫不用切？</p><p>虽然侍卫也在皇宫，但是他们有着严格的管理制度。</p><ol><li>侍卫通常不能进入后宫。侍卫一般只是守卫皇宫外围和皇帝身边，不允许进入妃子住的地方。</li><li>侍卫不能单独在皇宫里面乱逛。你在上班哦，以为逛菜市场呀。</li><li>侍卫实行轮班制。侍卫不会永远守在一个地方，通常一时守这里，一时守那里。没有与妃子们私通的机会。</li><li>侍卫通常是一群人一起巡逻，难道你要当着众人的面与妃子们交流？</li><li>即使皇帝下令抓捕妃子，也是太监动手，侍卫碰不到妃子的！</li></ol></blockquote><p>现在说说皇帝身边的太监。</p><p>皇帝跟普通的老板一样，一旦某一个太监使得顺手了，也就懒得换了。于是这个太监就会成为皇帝身边的左右手。</p><p><strong>皇帝在朝廷上并非可以为所欲为。</strong></p><p>如果读者对明朝的历史有所了解，可以发现，明朝的很多皇帝在大臣们面前并不是那么强势，有时候，皇帝居然被大臣们压得像猫一样！不会吧？怎么会这样！皇帝虽然有生杀大权，但是，他不能当疯子，不能说杀谁就杀谁的。他要行使权力总得令人心服口服。于是问题就来了，在嘴巴上，他不一定斗得过下面这群当了几十年官的老狐狸们！如明朝的一些皇帝，想下令做什么事情，下面的大臣就会跑出来说不行不行呀，这违反了祖宗定下来的规矩，这样上天会不高兴的！这时候皇帝必须有足够的理由说服大臣们，你不能总是一句“拉出去砍了”完事。然而，皇帝的政治经验比起大臣差得太远了！他是那么的无力！</p><p>到底是你们做皇帝还是我做皇帝！</p><p><strong>有时候，太监成为了皇帝最信任的政治助手</strong></p><p>一开始，太监只是皇帝身边做杂活的。但是时间一长，有些太监就升级了，他们成功获得皇帝的信任，成了左右手。皇帝一刻也离不开他们。再后来，皇帝和太监的关系又升级了。</p><p>前面已经说过，皇帝在朝廷不一定可以呼风唤雨，他也有很多烦恼。有时候，他会忍不住向身边的太监们倾诉。这时候，身边那些高情商的太监们就有了知遇之恩了，他们有了成为皇帝心腹的机会！</p><p>这些太监们当然会奉迎皇帝。他们会帮皇帝们出主意啊什么的，后来，皇帝干脆派他们办事了。于是，他们开始获得权力了。</p><p>他们办事是皇帝委任的，谁敢挡啊。你敢跟皇帝说这不符合朝廷的法制？中国一向是人情大于天，你事事按规矩办事，得罪的人可不知有多少。</p><p>皇帝为了制衡大臣，就开始倚重太监了。太监要办事，总要权力吧？慢慢，太监的权力越来越大了。</p><p><strong>没有人是傻子，太监也不是</strong></p><p>前面已经说过了，人都是趋利的。太监不会例外。</p><p>太监获得权力后，大家都会容让他，大家都要给他面子，这时候他怎么办呢？当然是想方设法保住自己的地位啦。<strong>他的一切行为无非是为自己着想。</strong></p><ol><li>他知道他不能得罪皇帝。</li><li>他知道换一个皇帝他不一定继续受宠。</li><li>他知道出来混，早晚都要还的。唯一不用还的办法是继续受宠。</li><li>他知道为了保住自己的地位，不择手段是必要的。对敌人仁慈就是对自己残忍。</li><li>他知道他的行为一开始就没有合法性。（没有哪一个朝代公开允许太监有权）</li></ol><p>为了证明自己不是傻子，太监只能混乱朝纲。</p><ol><li>失宠会生不如死。于是宁愿没有羞耻心，宁愿坏事做尽，就是不能失宠。</li><li>皇帝年纪小一点好控制。于是有太监专权者喜欢立幼，然后继续做坏事。</li><li>皇帝太有能力自己就危险了。于是有太监专权者想办法阻止有能力的人当皇帝，宁愿扶持没有能力的人做皇帝。</li><li>掌握军队指挥权更保险。他们得到军权后又会进一步危害朝廷。</li><li>他们知道所有人都看他们不顺眼，但他们不在乎。</li></ol><p>上面分析已经充分论证了太监专权的前因后果。</p><h3 id="政策为何会变样：治理国家的艰难之处"><a href="#政策为何会变样：治理国家的艰难之处" class="headerlink" title="政策为何会变样：治理国家的艰难之处"></a><a href="https://zhuanlan.zhihu.com/p/31956198" target="_blank" rel="noopener">政策为何会变样：治理国家的艰难之处</a></h3><p><strong>对上不对下，怎么可能不变样</strong></p><p>你讨好的对象，到底是老百姓还是领导？</p><p>真正决定你前途的是你的领导，不是老百姓。领导也一样。这样的体制，政策怎么可能不变样呢？上面已经论证过，人都是趋利的。人几乎一切行为本质上都不过是为了自己。</p><p>决定你命运的是老百姓，你就会讨好老百姓；决定你命运的只是你的领导，你就只会讨好你领导。</p><p>这样的艰难是出在根本制度上，没有什么解决方案的。</p><h3 id="为什么历史上有名的重臣，他们学的四书五经，读的是圣贤书，都没有学数理化，照样把国家治理的很好？"><a href="#为什么历史上有名的重臣，他们学的四书五经，读的是圣贤书，都没有学数理化，照样把国家治理的很好？" class="headerlink" title="为什么历史上有名的重臣，他们学的四书五经，读的是圣贤书，都没有学数理化，照样把国家治理的很好？"></a>为什么历史上有名的重臣，他们学的四书五经，读的是圣贤书，都没有学数理化，照样把国家治理的很好？</h3><p>这个问题本身论述有误。</p><p>怎么知道“照样把国家治理得很好”呢？中国历史那么长，真正社会欣欣向荣的时间很短，大部分时间都是一团糟。事实上，中国根本就没有产生过科学的政治理论。四书五经，只不过是在说道理。这些书籍，只能开启官员们的心智而已，根本不能使大家形成科学的共识。中国古代的官员讨论国家政策时，都只是各执己见，公说公有理，婆说婆有理，最后让皇帝拍板而已。</p><h2 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h2><p>没有监督的权力一定会成为祸害的根源；</p><p>权力导致腐败，绝对的权力导致绝对的腐败。</p>]]></content>
      
      <categories>
          
          <category> 政治历史 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 政策 </tag>
            
            <tag> 社会 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>PCA的数学原理(转)</title>
      <link href="/2018/05/09/PCA%E6%95%B0%E5%AD%A6%E5%8E%9F%E7%90%86/"/>
      <url>/2018/05/09/PCA%E6%95%B0%E5%AD%A6%E5%8E%9F%E7%90%86/</url>
      <content type="html"><![CDATA[<p>PCA（Principal Component Analysis）是一种常用的数据分析方法。PCA通过线性变换将原始数据变换为一组各维度线性无关的表示，可用于提取数据的主要特征分量，常用于高维数据的降维。网上关于PCA的文章有很多，但是大多数只描述了PCA的分析过程，而没有讲述其中的原理。这篇文章的目的是介绍PCA的基本数学原理，帮助读者了解PCA的工作机制是什么。</p><p>当然我并不打算把文章写成纯数学文章，而是希望用直观和易懂的方式叙述PCA的数学原理，所以整个文章不会引入严格的数学推导。希望读者在看完这篇文章后能更好的明白PCA的工作原理。</p><h2 id="1-数据的向量表示及降维问题"><a href="#1-数据的向量表示及降维问题" class="headerlink" title="1. 数据的向量表示及降维问题"></a>1. 数据的向量表示及降维问题</h2><p>一般情况下，在数据挖掘和机器学习中，数据被表示为向量。例如某个淘宝店2012年全年的流量及交易情况可以看成一组记录的集合，其中每一天的数据是一条记录，格式如下：</p><p>(日期, 浏览量, 访客数, 下单数, 成交数, 成交金额)</p><p>其中“日期”是一个记录标志而非度量值，而数据挖掘关心的大多是度量值，因此如果我们忽略日期这个字段后，我们得到一组记录，每条记录可以被表示为一个五维向量，其中一条看起来大约是这个样子：</p><script type="math/tex; mode=display">(500,240,25,13,2312.15)^T</script><p>注意这里我用了转置，因为习惯上使用列向量表示一条记录（后面会看到原因），本文后面也会遵循这个准则。不过为了方便有时我会省略转置符号，但我们说到向量默认都是指列向量。</p><p>我们当然可以对这一组五维向量进行分析和挖掘，不过我们知道，很多机器学习算法的复杂度和数据的维数有着密切关系，甚至与维数呈指数级关联。当然，这里区区五维的数据，也许还无所谓，但是实际机器学习中处理成千上万甚至几十万维的情况也并不罕见，在这种情况下，机器学习的资源消耗是不可接受的，因此我们必须对数据进行降维。</p><p>降维当然意味着信息的丢失，不过鉴于实际数据本身常常存在的相关性，我们可以想办法在降维的同时将信息的损失尽量降低。</p><p>举个例子，假如某学籍数据有两列M和F，其中M列的取值是如何此学生为男性取值1，为女性取值0；而F列是学生为女性取值1，男性取值0。此时如果我们统计全部学籍数据，会发现对于任何一条记录来说，当M为1时F必定为0，反之当M为0时F必定为1。在这种情况下，我们将M或F去掉实际上没有任何信息的损失，因为只要保留一列就可以完全还原另一列。</p><p>当然上面是一个极端的情况，在现实中也许不会出现，不过类似的情况还是很常见的。例如上面淘宝店铺的数据，从经验我们可以知道，“浏览量”和“访客数”往往具有较强的相关关系，而“下单数”和“成交数”也具有较强的相关关系。这里我们非正式的使用“相关关系”这个词，可以直观理解为“当某一天这个店铺的浏览量较高（或较低）时，我们应该很大程度上认为这天的访客数也较高（或较低）”。后面的章节中我们会给出相关性的严格数学定义。</p><p>这种情况表明，如果我们删除浏览量或访客数其中一个指标，我们应该期待并不会丢失太多信息。因此我们可以删除一个，以降低机器学习算法的复杂度。</p><p>上面给出的是降维的朴素思想描述，可以有助于直观理解降维的动机和可行性，但并不具有操作指导意义。例如，我们到底删除哪一列损失的信息才最小？亦或根本不是单纯删除几列，而是通过某些变换将原始数据变为更少的列但又使得丢失的信息最小？到底如何度量丢失信息的多少？如何根据原始数据决定具体的降维操作步骤？</p><p>要回答上面的问题，就要对降维问题进行数学化和形式化的讨论。而PCA是一种具有严格数学基础并且已被广泛采用的降维方法。下面我不会直接描述PCA，而是通过逐步分析问题，让我们一起重新“发明”一遍PCA。</p><h2 id="2-向量的表示及基变换"><a href="#2-向量的表示及基变换" class="headerlink" title="2. 向量的表示及基变换"></a>2. 向量的表示及基变换</h2><p>既然我们面对的数据被抽象为一组向量，那么下面有必要研究一些向量的数学性质。而这些数学性质将成为后续导出PCA的理论基础。</p><h2 id="3-内积与投影"><a href="#3-内积与投影" class="headerlink" title="3. 内积与投影"></a>3. 内积与投影</h2><p>下面先来看一个高中就学过的向量运算：内积。两个维数相同的向量的内积被定义为：</p><script type="math/tex; mode=display">(a_1,a_2,...,a_n)^T  \cdot (b_1,b_2,...,b_n)^T=a_1b_1+a_2b_2+...+a_nb_n</script><p>内积运算将两个向量映射为一个实数。其计算方式非常容易理解，但是其意义并不明显。下面我们分析内积的几何意义。假设<img src="https://www.zhihu.com/equation?tex=A" alt="A">和<img src="https://www.zhihu.com/equation?tex=B" alt="B">是两个<img src="https://www.zhihu.com/equation?tex=n" alt="n">维向量，我们知道<img src="https://www.zhihu.com/equation?tex=n" alt="n">维向量可以等价表示为<img src="https://www.zhihu.com/equation?tex=n" alt="n">维空间中的一条从原点发射的有向线段，为了简单起见我们假设<img src="https://www.zhihu.com/equation?tex=A" alt="A">和<img src="https://www.zhihu.com/equation?tex=B" alt="B">均为二维向量，则$ A=(x_1,y_1),B=(x_2,y_2) $。则在二维平面上<img src="https://www.zhihu.com/equation?tex=A" alt="A">和<img src="https://www.zhihu.com/equation?tex=B" alt="B">可以用两条发自原点的有向线段表示，见下图：</p><p><img src="https://pic4.zhimg.com/80/8d64151ceed0eed4d4708d8d9e6374dc_hd.jpg" alt="图片"></p><p>好，现在我们从<img src="https://www.zhihu.com/equation?tex=A" alt="A">点向<img src="https://www.zhihu.com/equation?tex=B" alt="B">所在直线引一条垂线。我们知道垂线与<img src="https://www.zhihu.com/equation?tex=B" alt="B">的交点叫做<img src="https://www.zhihu.com/equation?tex=A" alt="A">在<img src="https://www.zhihu.com/equation?tex=B" alt="B">上的投影，再设<img src="https://www.zhihu.com/equation?tex=A" alt="A">与<img src="https://www.zhihu.com/equation?tex=B" alt="B">的夹角是$\alpha$，则投影的矢量长度为$\vert A \vert cos(\alpha)$,其中$\vert A \vert=\sqrt{x_1^2+y_1^2}$是向量<img src="https://www.zhihu.com/equation?tex=A" alt="A">的模，也就是<img src="https://www.zhihu.com/equation?tex=A" alt="A">线段的标量长度。</p><p>注意这里我们专门区分了矢量长度和标量长度，标量长度总是大于等于0，值就是线段的长度；而矢量长度可能为负，其绝对值是线段长度，而符号取决于其方向与标准方向相同或相反。</p><p>到这里还是看不出内积和这东西有什么关系，不过如果我们将内积表示为另一种我们熟悉的形式：</p><script type="math/tex; mode=display">A \cdot B=\vert A\vert  \vert B \vert cos(\alpha)</script><p>现在事情似乎是有点眉目了：<img src="https://www.zhihu.com/equation?tex=A" alt="A">与<img src="https://www.zhihu.com/equation?tex=B" alt="B">的内积等于<img src="https://www.zhihu.com/equation?tex=A" alt="A">到<img src="https://www.zhihu.com/equation?tex=B" alt="B">的投影长度乘以<img src="https://www.zhihu.com/equation?tex=B" alt="B">的模。再进一步，如果我们假设<img src="https://www.zhihu.com/equation?tex=B" alt="B">的模为1，即让$\vert B \vert = 1$，那么就变成了：</p><script type="math/tex; mode=display">A \cdot B = \vert A \vert cos(\alpha)</script><p>也就是说，设向量<img src="https://www.zhihu.com/equation?tex=B" alt="B">的模为1，则<img src="https://www.zhihu.com/equation?tex=A" alt="A">与<img src="https://www.zhihu.com/equation?tex=B" alt="B">的内积值等于<img src="https://www.zhihu.com/equation?tex=A" alt="A">向<img src="https://www.zhihu.com/equation?tex=B" alt="B">所在直线投影的矢量长度！这就是内积的一种几何解释，也是我们得到的第一个重要结论。在后面的推导中，将反复使用这个结论。</p><h2 id="4-基"><a href="#4-基" class="headerlink" title="4. 基"></a>4. 基</h2><p>下面我们继续在二维空间内讨论向量。上文说过，一个二维向量可以对应二维笛卡尔直角坐标系中从原点出发的一个有向线段。例如下面这个向量：</p><p><img src="https://pic2.zhimg.com/df6a713c1b97cc55bd20afce46ace718_r.jpg" alt=""></p><p>在代数表示方面，我们经常用线段终点的点坐标表示向量，例如上面的向量可以表示为$(3,2)$，这是我们再熟悉不过的向量表示。</p><p>不过我们常常忽略，只有一个$(3,2)$本身是不能够精确表示一个向量的。我们仔细看一下，这里的3实际表示的是向量在x轴上的投影值是3，在y轴上的投影值是2。也就是说我们其实隐式引入了一个定义：以x轴和y轴上正方向长度为1的向量为标准。那么一个向量$(3,2)$实际是说在x轴投影为3而y轴的投影为2。注意投影是一个矢量，所以可以为负。</p><p>更正式的说，向量(x,y)实际上表示线性组合：</p><script type="math/tex; mode=display">x(1,0)^T+y(0,1)^T</script><p>不难证明所有二维向量都可以表示为这样的线性组合。此处$(1,0)$和$(0,1)$叫做二维空间中的一组基。</p><p><img src="https://pic3.zhimg.com/4533331b5b4b5ea98c90f2abed81d470_r.jpg" alt=""><strong>所以，要准确描述向量，首先要确定一组基，然后给出在基所在的各个直线上的投影值，就可以了。</strong>只不过我们经常省略第一步，而默认以$(1,0)$和$(0,1)$为基。</p><p>我们之所以默认选择$(1,0)$和$(0,1)$为基，当然是比较方便，因为它们分别是x和y轴正方向上的单位向量，因此就使得二维平面上点坐标和向量一一对应，非常方便。但实际上任何两个线性无关的二维向量都可以成为一组基，所谓线性无关在二维平面内可以直观认为是两个不在一条直线上的向量。</p><p>例如，$(1,1)$和$(-1,1)$也可以成为一组基。一般来说，我们希望基的模是1，因为从内积的意义可以看到，如果基的模是1，那么就可以方便的用向量点乘基而直接获得其在新基上的坐标了！实际上，对应任何一个向量我们总可以找到其同方向上模为1的向量，只要让两个分量分别除以模就好了。例如，上面的基可以变为$({1 \over \sqrt{2}},{1 \over \sqrt{2}})$和$(-{1 \over \sqrt{2}},{1 \over \sqrt{2}})$ 。</p><p>现在，我们想获得 $(3,2)$在新基上的坐标，即在两个方向上的投影矢量值，那么根据内积的几何意义，我们只要分别计算$(3,2)$和两个基的内积，不难得到新的坐标为$({5 \over \sqrt{2}},-{1 \over \sqrt{2}})$。下图给出了新的基以及$(3,2)$在新基上坐标值的示意图：</p><p><img src="https://pic4.zhimg.com/ff47d66fa67d12918e4e83678fa6b78d_r.jpg" alt="">另外这里要注意的是，我们列举的例子中基是正交的（即内积为0，或直观说相互垂直），但可以成为一组基的唯一要求就是线性无关，非正交的基也是可以的。不过因为正交基有较好的性质，所以一般使用的基都是正交的。</p><h2 id="5-基变换的矩阵表示"><a href="#5-基变换的矩阵表示" class="headerlink" title="5. 基变换的矩阵表示"></a>5. 基变换的矩阵表示</h2><p>下面我们找一种简便的方式来表示基变换。还是拿上面的例子，想一下，将$(3,2)$变换为新基上的坐标，就是用$(3,2)$与第一个基做内积运算，作为第一个新的坐标分量，然后用$(3,2)$与第二个基做内积运算，作为第二个新坐标的分量。实际上，我们可以用矩阵相乘的形式简洁的表示这个变换：</p><script type="math/tex; mode=display">\begin{bmatrix} {1 \over \sqrt{2}}&{1 \over \sqrt{2}} \\ -{1 \over \sqrt{2}}&{1 \over \sqrt{2}}  \end{bmatrix} \begin{bmatrix} 3\\2 \end{bmatrix} = \begin{bmatrix} {5 \over \sqrt{2}} \\ -{1 \over \sqrt{2}} \end{bmatrix}</script><p>太漂亮了！其中矩阵的两行分别为两个基，乘以原向量，其结果刚好为新基的坐标。可以稍微推广一下，如果我们有m个二维向量，只要将二维向量按列排成一个两行m列矩阵，然后用“基矩阵”乘以这个矩阵，就得到了所有这些向量在新基下的值。例如$(1,1),(2,2),(3,3)$想变换到刚才那组基上，则可以这样表示：</p><script type="math/tex; mode=display">\begin{bmatrix} {1 \over \sqrt{2}}&{1 \over \sqrt{2}} \\ -{1 \over \sqrt{2}}&{1 \over \sqrt{2}}  \end{bmatrix} \begin{bmatrix} 1&2&3\\1&2&3 \end{bmatrix} = \begin{bmatrix} {2 \over \sqrt{2}} & {4 \over \sqrt{2}}& {6 \over \sqrt{2}} \\ 0&0&0 \end{bmatrix}</script><p>于是一组向量的基变换被干净的表示为矩阵的相乘。</p><p>一般的，如果我们有M个N维向量，想将其变换为由R个N维向量表示的新空间中，那么首先将R个基按行组成矩阵A，然后将向量按列组成矩阵B，那么两矩阵的乘积AB就是变换结果，其中AB的第m列为A中第m列变换后的结果。</p><p>数学表示为：</p><script type="math/tex; mode=display">\begin {pmatrix}  p_1\\p_2\\ \vdots \\ p_R  \end{pmatrix} \begin {pmatrix} a_1&a_2&\cdots &a_M \end{pmatrix}=\begin {pmatrix} p_1a_1&p_1a_2&\cdots &p_1a_M \\ p_2a_1&p_2a_2&\cdots &p_2a_M \\ \vdots & \vdots & \ddots & \vdots \\   p_Ra_1&p_Ra_2&\cdots &p_Ra_M   \end{pmatrix}</script><p>其中$p_i$是一个行向量，表示第$i$个基，$a_j$是一个列向量，表示第$j$个原始数据记录。</p><p>特别要注意的是，这里R可以小于N，而R决定了变换后数据的维数。也就是说，我们可以将一N维数据变换到更低维度的空间中去，变换后的维度取决于基的数量。因此这种矩阵相乘的表示也可以表示降维变换。</p><p>最后，上述分析同时给矩阵相乘找到了一种物理解释：两个矩阵相乘的意义是将右边矩阵中的每一列列向量变换到左边矩阵中每一行行向量为基所表示的空间中去。更抽象的说，一个矩阵可以表示一种线性变换。很多同学在学线性代数时对矩阵相乘的方法感到奇怪，但是如果明白了矩阵相乘的物理意义，其合理性就一目了然了。</p><h2 id="6-协方差矩阵及优化目标"><a href="#6-协方差矩阵及优化目标" class="headerlink" title="6. 协方差矩阵及优化目标"></a>6. 协方差矩阵及优化目标</h2><p>上面我们讨论了选择不同的基可以对同样一组数据给出不同的表示，而且如果基的数量少于向量本身的维数，则可以达到降维的效果。但是我们还没有回答一个最最关键的问题：如何选择基才是最优的。或者说，如果我们有一组N维向量，现在要将其降到K维（K小于N），那么我们应该如何选择K个基才能最大程度保留原有的信息？</p><p>要完全数学化这个问题非常繁杂，这里我们用一种非形式化的直观方法来看这个问题。</p><p>为了避免过于抽象的讨论，我们仍以一个具体的例子展开。假设我们的数据由五条记录组成，将它们表示成矩阵形式：</p><script type="math/tex; mode=display">\begin{pmatrix} 1&1&2&4&2 \\ 1&3&3&4&4  \end{pmatrix}</script><p>其中每一列为一条数据记录，而一行为一个字段。为了后续处理方便，我们首先将每个字段内所有值都减去字段均值，其结果是将每个字段都变为均值为0（这样做的道理和好处后面会看到）。</p><p>我们看上面的数据，第一个字段均值为2，第二个字段均值为3，所以变换后：</p><script type="math/tex; mode=display">\begin{pmatrix} -1&-1&0&2&0 \\ -2&0&0&1&1 \end{pmatrix}</script><p>我们可以看下五条数据在平面直角坐标系内的样子：</p><p><img src="https://pic2.zhimg.com/e01296f282109b59e18086843866f81a_r.jpg" alt=""></p><p>现在问题来了：如果我们必须使用一维来表示这些数据，又希望尽量保留原始的信息，你要如何选择？</p><p>通过上一节对基变换的讨论我们知道，这个问题实际上是要在二维平面中选择一个方向，将所有数据都投影到这个方向所在直线上，用投影值表示原始记录。这是一个实际的二维降到一维的问题。</p><p>那么如何选择这个方向（或者说基）才能尽量保留最多的原始信息呢？一种直观的看法是：希望投影后的投影值尽可能分散。</p><p>以上图为例，可以看出如果向x轴投影，那么最左边的两个点会重叠在一起，中间的两个点也会重叠在一起，于是本身四个各不相同的二维点投影后只剩下两个不同的值了，这是一种严重的信息丢失，同理，如果向y轴投影最上面的两个点和分布在x轴上的两个点也会重叠。所以看来x和y轴都不是最好的投影选择。我们直观目测，如果向通过第一象限和第三象限的斜线投影，则五个点在投影后还是可以区分的。</p><p>下面，我们用数学方法表述这个问题。</p><h2 id="7-方差"><a href="#7-方差" class="headerlink" title="7. 方差"></a>7. 方差</h2><p>上文说到，我们希望投影后投影值尽可能分散，而这种分散程度，可以用数学上的方差来表述。此处，一个字段的方差可以看做是每个元素与字段均值的差的平方和的均值，即：</p><script type="math/tex; mode=display">Var(a)={1 \over m} \sum_{i=1}^m(a_i-\mu)^2</script><p>由于上面我们已经将每个字段的均值都化为0了，因此方差可以直接用每个元素的平方和除以元素个数表示：</p><script type="math/tex; mode=display">Var(a)={1 \over m} \sum_{i=1}^ma_i^2</script><p>于是上面的问题被形式化表述为：寻找一个一维基，使得所有数据变换为这个基上的坐标表示后，方差值最大。</p><h2 id="8-协方差"><a href="#8-协方差" class="headerlink" title="8. 协方差"></a>8. 协方差</h2><p>对于上面二维降成一维的问题来说，找到那个使得方差最大的方向就可以了。不过对于更高维，还有一个问题需要解决。考虑三维降到二维问题。与之前相同，首先我们希望找到一个方向使得投影后方差最大，这样就完成了第一个方向的选择，继而我们选择第二个投影方向。</p><p>如果我们还是单纯只选择方差最大的方向，很明显，这个方向与第一个方向应该是“几乎重合在一起”，显然这样的维度是没有用的，因此，应该有其他约束条件。从直观上说，让两个字段尽可能表示更多的原始信息，我们是不希望它们之间存在（线性）相关性的，因为相关性意味着两个字段不是完全独立，必然存在重复表示的信息。</p><p>数学上可以用两个字段的协方差表示其相关性，由于已经让每个字段均值为0，则：</p><script type="math/tex; mode=display">Cov(x,y)={1 \over m}\sum_{i=1}^ma_ib_i</script><p>可以看到，在字段均值为0的情况下，两个字段的协方差简洁的表示为其内积除以元素数m。</p><p>当协方差为0时，表示两个字段完全独立。为了让协方差为0，我们选择第二个基时只能在与第一个基正交的方向上选择。因此最终选择的两个方向一定是正交的。</p><p>至此，我们得到了降维问题的优化目标：将一组N维向量降为K维（K大于0，小于N），其目标是选择K个单位（模为1）正交基，使得原始数据变换到这组基上后，各字段两两间协方差为0，而字段的方差则尽可能大（在正交的约束下，取最大的K个方差）。</p><h2 id="9-协方差矩阵"><a href="#9-协方差矩阵" class="headerlink" title="9. 协方差矩阵"></a>9. 协方差矩阵</h2><p>上面我们导出了优化目标，但是这个目标似乎不能直接作为操作指南（或者说算法），因为它只说要什么，但根本没有说怎么做。所以我们要继续在数学上研究计算方案。</p><p>我们看到，最终要达到的目的与字段内方差及字段间协方差有密切关系。因此我们希望能将两者统一表示，仔细观察发现，两者均可以表示为内积的形式，而内积又与矩阵相乘密切相关。于是我们来了灵感：</p><p>假设我们只有a和b两个字段，那么我们将它们按行组成矩阵X：</p><script type="math/tex; mode=display">X=\begin{pmatrix} a_1&a_2&...&a_m \\b_1&b_2&...&b_m  \end{pmatrix}</script><p>然后我们用X乘以X的转置，并乘上系数1/m：</p><script type="math/tex; mode=display">{1 \over m}XX^T=\begin{pmatrix} {1\over m } \sum_{i=1}^m a_i^2 &  {1\over m } \sum_{i=1}^m a_ib_i \\ {1\over m } \sum_{i=1}^m a_ib_i  & {1\over m } \sum_{i=1}^m b_i^2  \end{pmatrix}</script><p>奇迹出现了！这个矩阵对角线上的两个元素分别是两个字段的方差，而其它元素是a和b的协方差。两者被统一到了一个矩阵的。</p><p>根据矩阵相乘的运算法则，这个结论很容易被推广到一般情况：</p><p>设我们有<img src="https://www.zhihu.com/equation?tex=m" alt="m">个<img src="https://www.zhihu.com/equation?tex=n" alt="n">维数据记录，将其按列排成<img src="https://www.zhihu.com/equation?tex=n" alt="n">乘<img src="https://www.zhihu.com/equation?tex=m" alt="m">的矩阵<img src="https://www.zhihu.com/equation?tex=+X" alt=" X">，设$C={1 \over m }XX^T$</p><p>，则<img src="https://www.zhihu.com/equation?tex=C" alt="C">是一个对称矩阵，其对角线分别个各个字段的方差，而第$i$行$j$列和$j$行$i$列元素相同，表示$i$和两个字段的$j$协方差。</p><h2 id="10-协方差矩阵对角化"><a href="#10-协方差矩阵对角化" class="headerlink" title="10. 协方差矩阵对角化"></a>10. 协方差矩阵对角化</h2><p>根据上述推导，我们发现要达到优化目前，等价于将协方差矩阵对角化：即除对角线外的其它元素化为0，并且在对角线上将元素按大小从上到下排列，这样我们就达到了优化目的。这样说可能还不是很明晰，我们进一步看下原矩阵与基变换后矩阵协方差矩阵的关系：</p><p>设原始数据矩阵X对应的协方差矩阵为C，而P是一组基按行组成的矩阵，设Y=PX，则Y为X对P做基变换后的数据。设Y的协方差矩阵为D，我们推导一下D与C的关系:</p><script type="math/tex; mode=display">D={1 \over m} YY^T   ={1 \over m} (PX)(PX)^T    ={1 \over m} PXX^TP^T    =P({1 \over m}XX^T)P^T    = PCP^T</script><p>现在事情很明白了！我们要找的P不是别的，而是能让原始协方差矩阵对角化的P。换句话说，优化目标变成了寻找一个矩阵P，满足$PCP^T$是一个对角矩阵，并且对角元素按从大到小依次排列，那么P的前K行就是要寻找的基，用P的前K行组成的矩阵乘以X就使得X从N维降到了K维并满足上述优化条件。</p><p>至此，我们离“发明”PCA还有仅一步之遥！</p><p>现在所有焦点都聚焦在了协方差矩阵对角化问题上，有时，我们真应该感谢数学家的先行，因为矩阵对角化在线性代数领域已经属于被玩烂了的东西，所以这在数学上根本不是问题。</p><p>由上文知道，协方差矩阵<img src="https://www.zhihu.com/equation?tex=C" alt="C">是一个是对称矩阵，在线性代数上，实对称矩阵有一系列非常好的性质：</p><ol><li>实对称矩阵不同特征值对应的特征向量必然正交。</li><li>设特征向量$\lambda$重数为r，则必然存在r个线性无关的特征向量对应于$\lambda$，因此可以将这r个特征向量单位正交化。</li></ol><p>由上面两条可知，一个<img src="https://www.zhihu.com/equation?tex=n" alt="n">行<img src="https://www.zhihu.com/equation?tex=n" alt="n">列的实对称矩阵一定可以找到n个单位正交特征向量，设这<img src="https://www.zhihu.com/equation?tex=n" alt="n">个特征向量为$e_1,e_2,…,e_n$，我们将其按列组成矩阵：</p><script type="math/tex; mode=display">E=\begin{pmatrix} e_1&e_2 &...&e_n\end{pmatrix}</script><p>则对协方差矩阵C有如下结论：</p><script type="math/tex; mode=display">E^TCE=\Lambda=\begin{pmatrix} \lambda_1&&&\\& \lambda_2&&\\&&\ddots&\\&&&\lambda_n \end{pmatrix}</script><p>其中$\Lambda$为对角矩阵，其对角元素为各特征向量对应的特征值（可能有重复）。</p><p> 以上结论不再给出严格的数学证明，对证明感兴趣的朋友可以参考线性代数书籍关于“实对称矩阵对角化”的内容。</p><p>到这里，我们发现我们已经找到了需要的矩阵P：</p><script type="math/tex; mode=display">P=E^T</script><p>P是协方差矩阵的特征向量单位化后按行排列出的矩阵，其中每一行都是C的一个特征向量。如果设P按照$\Lambda$中特征值的从大到小，将特征向量从上到下排列，则用P的前K行组成的矩阵乘以原始数据矩阵X，就得到了我们需要的降维后的数据矩阵Y。</p><p>至此我们完成了整个PCA的数学原理讨论。在下面的一节，我们将给出PCA的一个实例。</p><h2 id="11-算法及实例"><a href="#11-算法及实例" class="headerlink" title="11. 算法及实例"></a>11. 算法及实例</h2><p>为了巩固上面的理论，我们在这一节给出一个具体的PCA实例。</p><p><strong>PCA算法</strong></p><p>总结一下PCA的算法步骤：</p><p>设有m条n维数据。</p><ol><li>将原始数据按列组成n行m列矩阵X</li><li>将X的每一行（代表一个属性字段）进行零均值化，即减去这一行的均值</li><li>求出协方差矩阵$C={1\over m}XX^T$</li><li>求出协方差矩阵的特征值及对应的特征向量</li><li>将特征向量按对应特征值大小从上到下按行排列成矩阵，取前k行组成矩阵P</li><li>Y=PX即为降维到k维后的数据</li></ol><p><strong>实例1</strong></p><p>这里以上文提到的</p><script type="math/tex; mode=display">\begin{pmatrix} -1&-1&0&2&0 \\ -2&0&0&1&1\end{pmatrix}</script><p>为例，我们用PCA方法将这组二维数据其降到一维。</p><p>因为这个矩阵的每行已经是零均值，这里我们直接求协方差矩阵：</p><script type="math/tex; mode=display">C={1 \over 5}\begin{pmatrix}-1&-1&0&2&0 \\ -2&0&0&1&1 \end{pmatrix}\begin{pmatrix}-1&-2\\-1&0\\0&0\\2&1\\0&1 \end{pmatrix}=\begin{pmatrix}{6\over 5}&{4\over 5}\\ {4\over 5}&{6\over 5} \end{pmatrix}</script><p>然后求其特征值和特征向量，具体求解方法不再详述，可以参考相关资料。求解后特征值为:</p><script type="math/tex; mode=display">\lambda_1=2,\lambda_2={2\over5}</script><p>其对应的特征向量分别是：</p><script type="math/tex; mode=display">C_1=\begin{pmatrix} 1\\1\end{pmatrix},C_2=\begin{pmatrix} -1\\1\end{pmatrix}</script><p>其中对应的特征向量分别是一个通解，$c_1$和可$c_2$取任意实数。那么标准化后的特征向量为：</p><script type="math/tex; mode=display">\begin{pmatrix} {1\over \sqrt{2}}\\{1\over \sqrt{2}}\end{pmatrix},\begin{pmatrix} -{1\over \sqrt{2}}\\{1\over \sqrt{2}}\end{pmatrix}</script><p>因此我们的矩阵P是：</p><script type="math/tex; mode=display">P=\begin{pmatrix} {1\over \sqrt{2}}&{1\over \sqrt{2}}\\-{1\over \sqrt{2}}&{1\over \sqrt{2}}\end{pmatrix}</script><p>可以验证协方差矩阵C的对角化：</p><script type="math/tex; mode=display">PCP^T=\begin{pmatrix} {1\over \sqrt{2}}&{1\over \sqrt{2}}\\-{1\over \sqrt{2}}&{1\over \sqrt{2}}\end{pmatrix}\begin{pmatrix} {6\over 5}&{4\over 5}\\{4 \over 5}&{6\over 5}\end{pmatrix}\begin{pmatrix} {1\over \sqrt{2}}&-{1\over \sqrt{2}}\\{1\over \sqrt{2}}&{1\over \sqrt{2}}\end{pmatrix}=\begin{pmatrix}2&0\\0&{2\over 5}\end{pmatrix}</script><p>最后我们用P的第一行乘以数据矩阵，就得到了降维后的表示：</p><script type="math/tex; mode=display">Y=\begin{pmatrix}{1\over \sqrt{2}}&{1\over \sqrt{2}} \end{pmatrix}\begin{pmatrix} -1&-1&0&2&0\\ -2&0&0&1&1\end{pmatrix}=\begin{pmatrix}-{3\over \sqrt{2}}&-{1\over \sqrt{2}}&0&{3\over \sqrt{2}}& -{1\over \sqrt{2}} \end{pmatrix}</script><p><img src="https://pic3.zhimg.com/2988668d28bfefee84b03bbff7dde06f_r.jpg" alt="">降维结果如上图。</p><p><strong>实例2</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">function linear_PCA </span><br><span class="line"></span><br><span class="line">%% PARAMETERS</span><br><span class="line"></span><br><span class="line">N = <span class="number">500</span>;% number of data points</span><br><span class="line">R = [<span class="number">-.9</span> <span class="number">.4</span>; <span class="number">.1</span> <span class="number">.2</span>];% covariance matrix</span><br><span class="line"></span><br><span class="line">%% PROGRAM</span><br><span class="line">tic</span><br><span class="line"></span><br><span class="line">X = randn(N,<span class="number">2</span>)*R;% correlated two-dimensional data</span><br><span class="line"></span><br><span class="line">[E,v,Xp] = km_pca(X,<span class="number">1</span>);% obtain eigenvector matrix E, eigenvalues v <span class="keyword">and</span> principal components Xp</span><br><span class="line"></span><br><span class="line">toc</span><br><span class="line">%% OUTPUT</span><br><span class="line">Y = X*E(:,<span class="number">2</span>);</span><br><span class="line">figure; hold on</span><br><span class="line">plot(X(:,<span class="number">1</span>),X(:,<span class="number">2</span>),<span class="string">'.'</span>)</span><br><span class="line">plot(E(<span class="number">1</span>,<span class="number">1</span>)*Xp,E(<span class="number">2</span>,<span class="number">1</span>)*Xp,<span class="string">'.r'</span>)</span><br><span class="line">plot(E(<span class="number">1</span>,<span class="number">2</span>)*Y,E(<span class="number">2</span>,<span class="number">2</span>)*Y,<span class="string">'.b'</span>)</span><br><span class="line">plot([<span class="number">0</span> E(<span class="number">1</span>,<span class="number">1</span>)],[<span class="number">0</span> E(<span class="number">2</span>,<span class="number">1</span>)],<span class="string">'g'</span>,<span class="string">'LineWidth'</span>,<span class="number">4</span>)</span><br><span class="line">plot([<span class="number">0</span> E(<span class="number">1</span>,<span class="number">2</span>)],[<span class="number">0</span> E(<span class="number">2</span>,<span class="number">2</span>)],<span class="string">'k'</span>,<span class="string">'LineWidth'</span>,<span class="number">4</span>)</span><br><span class="line">axis equal</span><br><span class="line">legend(<span class="string">'data'</span>,<span class="string">'first principal components'</span>,<span class="string">'second principal components'</span>,<span class="string">'first principal direction'</span>,<span class="string">'second principal direction'</span>)</span><br><span class="line">title(<span class="string">'linear PCA demo'</span>)</span><br><span class="line"></span><br><span class="line">function [E,v,Xp] = km_pca(X,m)</span><br><span class="line">N = size(X,<span class="number">1</span>);</span><br><span class="line">[E,V] = eig(X<span class="string">'*X/N);</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">v = diag(V);</span></span><br><span class="line"><span class="string">[v,ind] = sort(v,'</span>descend<span class="string">');</span></span><br><span class="line"><span class="string">E = E(:,ind);</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">Xp = X*E(:,1:m);</span></span><br></pre></td></tr></table></figure><p>结果</p><p><img src="https://pic3.zhimg.com/1908980ff0022446e3a27b78891f0181_r.jpg" alt=""></p><p>(说明，为了画图效果，计算协方差矩阵之前没有将数据中心化)</p><h2 id="12-进一步讨论"><a href="#12-进一步讨论" class="headerlink" title="12. 进一步讨论"></a>12. 进一步讨论</h2><p>根据上面对PCA的数学原理的解释，我们可以了解到一些PCA的能力和限制。PCA本质上是将方差最大的方向作为主要特征，并且在各个正交方向上将数据“离相关”，也就是让它们在不同正交方向上没有相关性。</p><p>因此，PCA也存在一些限制，例如它可以很好的解除线性相关，但是对于高阶相关性就没有办法了，对于存在高阶相关性的数据，可以考虑Kernel PCA，通过Kernel函数将非线性相关转为线性相关，关于这点就不展开讨论了。另外，PCA假设数据各主特征是分布在正交方向上，如果在非正交方向上存在几个方差较大的方向，PCA的效果就大打折扣了。</p><p>最后需要说明的是，PCA是一种无参数技术，也就是说面对同样的数据，如果不考虑清洗，谁来做结果都一样，没有主观参数的介入，所以PCA便于通用实现，但是本身无法个性化的优化。</p><p>希望这篇文章能帮助朋友们了解PCA的数学理论基础和实现原理，借此了解PCA的适用场景和限制，从而更好的使用这个算法。</p>]]></content>
      
      <categories>
          
          <category> 人工智能 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> PCA </tag>
            
        </tags>
      
    </entry>
    
  
  
</search>
